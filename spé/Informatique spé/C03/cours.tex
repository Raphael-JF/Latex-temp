\input{../../stock/en-tete_v4.tex}
\begin{document}
\begin{adjustwidth}{-3cm}{-3cm}
\input{../../stock/commands.tex}

\begin{implementation}{3.1}{parcours "Whatever First Search"}
    Il s'agit du parcours générique d'un graphe, dans lequel le \notion{sac} est une structure de donnée qui déterminera le mode de parcours.
    \begin{itemize}
        \item \textbf{Entrée}~:~un graphe $G = (S,A)$
        \item \textbf{Sortie}~:~dépendante du but du parcours
    \end{itemize}
    \begin{lstLNat}
    initialiser un sac contenant $S$
    tant que le sac n'est pas vide :
        $v$ = pop le premier élément du sac
        si $v$ n'est pas marqué :
            marquer $v$ et le traîter
            pour tout sommet $w$ voisin de $v$ :
                ajouter $w$ au sac
    \end{lstLNat}
\end{implementation}

\begin{implementation}{3.2}{parcours préfixe}
    Ici, le sac du parcours "Whaterver First Search" est \underline{une pile}
    \begin{lstOCaml}
    type graphe = int list array

    let parcours_pre g s =
    let n = Array.length g in (*nb sommets*)
    let non_vus = Array.make n true in
    let rec visite x voisins = 
        if non_vus.(x) then
            (print_int x;
            non_vus.(x) <- false);
        match voisins with
        | [] -> () (*plus de voisins à traiter*)
        | v::q when non_vus.(v) ->
            visite v g.(v);
            visite x q
        | v::q -> visite x q
    in visite s g.(s)
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{3.3}{parcours postfixe}
    Ici, le sac du parcours "Whaterver First Search" est \underline{une pile}
    \begin{lstOCaml}
    type graphe = int list array
    let parcours_post g s =
    let n = Array.length g in (*nb sommets*)
    let non_vus = Array.make n true in
    let rec visite x voisins = 
        if non_vus.(x) then 
            non_vus.(x) <- false;
        match voisins with
        | [] -> print_int x (*plus de voisins à traiter*)
        | v::q when non_vus.(v) ->
            visite v g.(v);
            visite x q
        | v::q -> visite x q
    in visite s g.(s)
    \end{lstOCaml}
\end{implementation}

\begin{definition}{3.4}{fonction heuristique admissible}
    Soit $G = (S,A,w)$ un graphe orienté pondéré. Dans le cadre de l'algorithme A* appliqué à $G$ d'un sommet $s$ à un sommet $t$, une \notion{heuristique $h:S \to \R_+$ est dite admissible} lorsque~:
    $$\forall v \in S, h(v) \leq \mr{d}(v,t) = \inf\Big\{\sum_{i=1}^{p-1} w(s_i, s_{i+1}),\, (s_1, \dots, s_p) \text{ chemin de }v=s_1 \text{ à } t = s_p\Big\}$$
    Autrement dit losque $h$ sous-estime la distance au sommet cible.
\end{definition}

\begin{definition}{3.5}{fonction heuristique monotone}
    Soit $G = (S,A,w)$ un graphe orienté pondéré. Dans le cadre de l'algorithme A* appliqué à $G$ d'un sommet $s$ à un sommet $t$, une \notion{heuristique $h:S \to \R_+$ est dite monotone} lorsque~:
    $$\begin{cases*}
    \forall (u,v) \in A,\, h(u) \leq w(u,v) + h(v) \\
    h(t) = 0
    \end{cases*}$$
    Par récurrence, on a également $h$ admissible.
\end{definition}

\begin{implementation}{algorithme de Kruskal}
    On exploite la structue Unir et Trouver pour la relation d'accessibilité, \underline{les classes sont alors les composantes connexes}.
    \begin{itemize}
        \item \textbf{Entrée}~: un graphe non orienté pondéré $G = (S,A,w)$
        \item \textbf{Sortie}~: un arbre couvrant de poids minimal de $G$
    \end{itemize}
    \begin{lstLNat}
    initialiser MST = $\varnothing$ //Minimal Spanning Tree
    pour tout $s \in S$ :
        créer la classe de représentant $s$
        
    trier la liste $A$ des arêtes par ordre croissant des poids
    pour tout $\{u,v\} \in A$ :
        si la classe de $u$ n'est pas la classe de $v$ :
            ajouter $\{u,v\}$ à MST
            unir les classes de $u$ et $v$
    renvoyer MST
    \end{lstLNat}
\end{implementation}


\begin{definition}{3.20}{couplage}
    Soit $G = (S,A)$ un graphe non orienté. Un \notion{couplage $C\subset A$ de $G$} est un ensemble d'arêtes tel que tout sommet $s \in S$ est l'extrémité d'au plus une arête de $C$.
\end{definition}

\begin{definition}{3.21}{couplage maximal}
    Soit $G = (S,A)$ un graphe non orienté. Un couplage $C \subset A$ de $G$ est dit \notion{maximal} s'il est maximal pour l'inclusion, \ie si on ne peut lui ajouter d'arête sans lui ôter sa nature de couplage~:
    $$\forall a \in A \setminus C,\, C \cup \{a\} \text{ n'est pas un couplage}$$
\end{definition}

\begin{definition}{3.22}{couplage maximum}
    Soit $G = (S,A)$ un graphe non orienté. Un couplage $C \subset A$ de $G$ est dit \notion{maximum} s'il est de cardinal maximal parmi les couplages de $G$~:
    $$\forall C' \text{ couplage de }G,\, \abs{C'} \leq \abs{C} $$
\end{definition}

\begin{definition}{3.23}{couplage parfait}
    Soit $G = (S,A)$ un graphe non orienté. Un couplage $C \subset A$ de $G$ est dit \notion{parfait} s'il recouvre tous les sommets de $G$~:
    $$\forall s \in S,\, \exists a \in C,\, s\in a$$
\end{definition}

\input{../../stock/pied.tex}