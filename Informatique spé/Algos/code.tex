\input{../../stock/en-tete_v4.tex}
\begin{document}
\begin{adjustwidth}{-3cm}{-3cm}
\input{../../stock/commands.tex}

\begin{implementation}{tri par fusion}
    \begin{lstOCaml}
    let rec casser l =
        match l with
        | [] -> [], []
        | [e1] -> [e1], []
        | e1::e2::q -> 
            let l1, l2 = casser q in
            e1::l1, e2::l2

    let rec fusion l1 l2 = 
        match l1, l2 with
        | [], _ -> l2
        | _, [] -> l1
        | e1::q1, e2::q2 ->
            if e2 > e1 then
                e1::(fusion q1 l2)
            else
                e2::(fusion l1 q2)

    let rec tri_fusion l =
        match l with
        | [] -> []
        | [e1] -> [e1]
        | _ -> 
            let l1, l2 = casser l in
            fusion (tri_fusion l1) (tri_fusion l2)
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{parcours en largeur d'un graphe (1/2)}
    \begin{lstOCaml}
    type graphe = int list array
    type file = {entrants:int list; sortants:int list}
        
    let file_vide () = {entrants = []; sortants = []}
                        
    let pop_opt f = 
        let rec retourne f1 =
            match f1.entrants with 
            | [] -> f1
            | e::q -> retourne {entrants=q; sortants = e::f1.sortants}
        in let f2 = if f.sortants = [] then retourne f else f
        in match f2.sortants with
        | [] -> file_vide (), None (* file vide *)
        | e::q -> {entrants=f2.entrants; sortants=q}, Some e
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{parcours en largeur d'un graphe (2/2)}
    \begin{lstOCaml}
    let rec ajoute f liste = 
        match liste with 
        | [] -> f
        | e::q -> ajoute {entrants = e::f.entrants; sortants = f.sortants} q            
        
    let parcours_largeur g s = 
        let n = Array.length g in
        let non_vus = Array.make n true in
        let rec parcours f = 
            match pop_opt f with 
            | _, None -> []
            | f1, Some v when non_vus.(v) ->
                non_vus.(v) <- false;
                v::(parcours (ajoute f1 g.(v)))
            | f1, Some v ->
                parcours f1
        in parcours {entrants=[s]; sortants=[]}
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{liste chainée en C (1/3)}
    \begin{lstC}
    typedef int elemtype;

    struct Maillon{
        elemtype val;
        struct Maillon* suivant;
    };
    typedef struct Maillon maillon;

    \end{lstC}
\end{implementation}

\begin{implementation}{liste chainée en C (2/3)}
    \begin{lstC}
    maillon* ajoute(elemtype x, maillon* c){
        maillon* res = malloc(sizeof(maillon));
        assert(res != NULL);
        res->val = x;
        res->suivant = c;
        return res;
    };
    \end{lstC}
\end{implementation}

\begin{implementation}{liste chainée en C (3/3)}
    \begin{lstC}
    int main(){
        maillon* a = ajoute(1,NULL);
        a = ajoute(2,a);
        a = ajoute(3,a);
        return 0;
    };
    \end{lstC}
\end{implementation}

\begin{implementation}{file d'entiers}
    \begin{lstC}
    struct Maillon{
        int val;
        struct Maillon* suivant;
    };
    typedef struct Maillon maillon;

    struct File{
        maillon* e; //maillon d'entrée
        maillon* s; //maillon de sortie
    };
    typedef struct File file;

    file* file_vide(){
        file* res = malloc(sizeof(file));
        assert(res != NULL);
        res->e = NULL;
        res->s = NULL;
        return res;
    }
    \end{lstC}
\end{implementation}

\begin{implementation}{file de priorité : type et fonction $\code{redim}$}
    \begin{lstOCaml}
    type tas_binaire_min = {
        mutable nb_elts:int; 
        mutable data: (char*int) array
    }

    let redim tbmin new_taille = 
        assert (new_taille >= tbmin.nb_elts);
        let new_data = Array.make new_taille ('\000',0) in
        for i=0 to tbmin.nb_elts - 1 do
            new_data.(i) <- tbmin.data.(i)
        done;
        tbmin.data <- new_data
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{file de priorité : fonction $\code{percole\_haut}$}
    \begin{lstOCaml}
    let percole_haut tbmin i_depart =
        let rec percole i =
            let daron = if (i-1)/2 < 0 then 0 else (i-1)/2 in
            if prio tbmin.data.(daron) > prio tbmin.data.(i) then begin
                let temp = tbmin.data.(i) in
                tbmin.data.(i) <- tbmin.data.(daron);
                tbmin.data.(daron) <- temp;
                percole daron;
            end
        in if tbmin.nb_elts <> 0 then
            percole i_depart
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{file de priorité : fonction $\code{percole\_bas}$}
    \begin{lstOCaml}
    let percole_bas tbmin i_depart =
        let rec percole i =
            let max = tbmin.nb_elts - 1 in
            let fils_g = if 2*i+1 <= max then 2*i+1 else max in
            let fils_d = if 2*i+2 <= max then 2*i+2 else max in
            if (prio tbmin.data.(fils_d) < prio tbmin.data.(i)|| 
                prio tbmin.data.(fils_g) < prio tbmin.data.(i)) then begin
                (*on va percoler le fils de plus basse priorité*)
                if prio tbmin.data.(fils_d) < prio tbmin.data.(fils_g) then
                    let temp = tbmin.data.(fils_d) in
                    tbmin.data.(fils_d) <- tbmin.data.(i);
                    tbmin.data.(i) <- temp;
                    percole fils_d
                else 
                    let temp = tbmin.data.(fils_g) in
                    tbmin.data.(fils_g) <- tbmin.data.(i);
                    tbmin.data.(i) <- temp;
                    percole fils_g
            end
        in if tbmin.nb_elts <> 0 then
            percole i_depart        
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{file de priorité : type et fonction $\code{file\_vide}$}
    \begin{lstOCaml}
    type tas_binaire_min = {
        mutable nb_elts:int; 
        mutable data: (char*int) array
    }

    let tbmin_vide () = {nb_elts = 0; data = [||]}
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{file de priorité : fonction $\code{ajoute}$ (qui remplace aussi)}
    \begin{lstOCaml}
    let tbmin_ajoute tbmin x p  =
        (*redimensionnement*)
        let n = Array.length tbmin.data in
        if tbmin.nb_elts >= n then 
            redim tbmin (2*n+1);
    
        (*vérification de la présence éventuelle de x*)
        let deja_present = ref false in (*indice de x si existence, sinon -1*)
        for i=0 to tbmin.nb_elts-1 do
            match tbmin.data.(i) with
            | (elt,prio) when elt = x -> 
                tbmin.data.(i) <- (x, p); 
                deja_present := true;
                if prio > p then 
                percole_bas tbmin i
                else if prio < p then
                percole_haut tbmin i
            | _ -> ()
        done;
    
        (*ajout et percolations vers le haut*)
        if not !deja_present then begin
            tbmin.data.(tbmin.nb_elts) <- (x,p);
            tbmin.nb_elts <- tbmin.nb_elts + 1;
            percole_haut tbmin (tbmin.nb_elts - 1)
        end
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{file de priorité : fonction $\code{pop\_opt}$}
    \begin{lstOCaml}
    let tbmin_pop tbmin =
        if tbmin.nb_elts = 0 then None else
    
        (*remplacement de la première case par la dernière*)
        let res =  tbmin.data.(0) in 
        tbmin.data.(0) <- tbmin.data.(tbmin.nb_elts-1);
        tbmin.nb_elts <- tbmin.nb_elts - 1;
    
        (*redimensionnement*)
        let n = Array.length tbmin.data in
        if tbmin.nb_elts <= n/2 then 
            redim tbmin (n/2);
    
        (*percolations du nouveau premier élément*)
        percole_bas tbmin 0;
        Some res
    \end{lstOCaml}
\end{implementation}

\input{../../stock/pied.tex}
