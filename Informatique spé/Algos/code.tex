\input{../../stock/en-tete_v4.tex}
\begin{document}
\begin{adjustwidth}{-3cm}{-3cm}
\input{../../stock/commands.tex}

\begin{implementation}{tri par fusion}
    \begin{lstOCaml}
    let rec casser l =
        match l with
        | [] -> [], []
        | [e1] -> [e1], []
        | e1::e2::q -> 
            let l1, l2 = casser q in
            e1::l1, e2::l2

    let rec fusion l1 l2 = 
        match l1, l2 with
        | [], _ -> l2
        | _, [] -> l1
        | e1::q1, e2::q2 ->
            if e2 > e1 then
                e1::(fusion q1 l2)
            else
                e2::(fusion l1 q2)

    let rec tri_fusion l =
        match l with
        | [] -> []
        | [e1] -> [e1]
        | _ -> 
            let l1, l2 = casser l in
            fusion (tri_fusion l1) (tri_fusion l2)
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{parcours en largeur d'un graphe (1/3)}
    \begin{lstOCaml}
    type file = {e:int list; s:int list}
    type graphe = int list array 
        
    let file_vide = {e=[]; s=[]}             
    
    let rec ajoute f liste = match liste with
        | [] -> f
        | elt::q -> ajoute {e=(elt::f.e); s=f.s} q 
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{parcours en largeur d'un graphe (2/3)}
    \begin{lstOCaml}
    let pop_opt f = 
        let rec retourne sub_f =
            match sub_f.e with
            | [] -> sub_f
            | elt::q -> retourne {e=q; s=elt::sub_f.s}   
        in let new_f = 
            if f.s = [] then
                retourne f 
            else f 
        in match new_f.s with 
        | [] -> file_vide, None
        | elt::q -> {e=new_f.e; s=q}, Some elt
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{parcours en largeur d'un graphe (3/3)}
    \begin{lstOCaml}
    let parcours_largeur g s =
        let n = Array.length g in
        let non_vus = Array.make n true in
        let rec parcours f =
            match (pop_opt f) with
            | _, None -> ()
            | new_f, Some v when non_vus.(v) ->
                non_vus.(v) <- false;
                print_int v;
                parcours (ajoute new_f g.(v))
            | new_f, Some v ->
                parcours new_f
        in parcours {e=[]; s=[s]} 
    \end{lstOCaml}
\end{implementation}

\begin{implementation}{liste chainée en C (1/3)}
    \begin{lstC}
    typedef int elemtype;

    struct Maillon{
        elemtype val;
        struct Maillon* suivant;
    };
    typedef struct Maillon maillon;

    \end{lstC}
\end{implementation}

\begin{implementation}{liste chainée en C (2/3)}
    \begin{lstC}
    maillon* ajoute(elemtype x, maillon* c){
        maillon* res = malloc(sizeof(maillon));
        assert(res != NULL);
        res->val = x;
        res->suivant = c;
        return res;
    };
    \end{lstC}
\end{implementation}

\begin{implementation}{liste chainée en C (3/3)}
    \begin{lstC}
    int main(){
        maillon* a = ajoute(1,NULL);
        a = ajoute(2,a);
        a = ajoute(3,a);
        return 0;
    };
    \end{lstC}
\end{implementation}

\begin{implementation}{file d'entiers}
    \begin{lstC}
    struct Maillon{
        int val;
        struct Maillon* suivant;
    };
    typedef struct Maillon maillon;

    struct File{
        maillon* e; //maillon d'entrée
        maillon* s; //maillon de sortie
    };
    typedef struct File file;

    file* file_vide(){
        file* res = malloc(sizeof(file));
        assert(res != NULL);
        res->e = NULL;
        res->s = NULL;
        return res;
    }
    \end{lstC}
\end{implementation}

\input{../../stock/pied.tex}