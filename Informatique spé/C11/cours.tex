\input{../../stock/en-tete_v5.tex}

\newcounter{chapitre}
\setcounter{chapitre}{11}

\title{\Large Chapitre 11 \\ \Huge Classes de complexité}

\begin{document}
\input{../../stock/commands.tex}
\maketitle


\section{Classes de complexité pour un problème de décision}
\subsection{Complexité}

\newcommand{\pbm}{\mc{P}}
\newcommand{\algo}{\mc{A}}
\newcommand{\reductibleP}{\leq_m^\mr{P}}
\newcommand{\troissat}{\textbf{3-SAT}\,}
\newcommand{\deuxsat}{\textbf{2-SAT}\,}
\newcommand{\cnfsat}{\textbf{CNF-SAT}\,}
\newcommand{\sat}{\textbf{SAT}\,}
\newcommand{\cheminham}{\textbf{CHEMIN-HAM}\,}
\newcommand{\cycleham}{\textbf{CYCLE-HAM}\,}


\begin{definition}{}{}
    Soit $\mc{P}$ un problème abstrait défini par une fonction $f:I\to S$. On considère un algorithme $\mc{A}$ "abstrait" qui le résout.\\
    On y associe un problème \notion{concret} en imposant des choix sur \notion{l'encodage} des entrées et des sorties.\\
    La \notion{complexité du problème concret} correspond à la complexité de l'implémentation de l'algorithme $\algo$ (sa réalisation concrète) pour le choix d'encodage.\\
    C'est-à-dire un ordre de grandeur du nombre d'opérations élémentaires réalisées par l'implémentation de l'algorithme pour une entrée en fonction de la \notion{taille de l'entrée} (espace occupé en mémoire pour son encodage).
\end{definition}

\begin{remarque}{}{cas du graphe}
    La taille de l'encodage pour un graphe~:
    \begin{itemize}
        \item matrice d'adjacence~: $\mc{O}(\abs{S}^2)$
        \item liste d'adjacence~: $\mc{O}(\abs{S} + \abs{A})$
    \end{itemize}
\end{remarque}

\begin{exemple}{}{taille de l'endage des entiers}
    Un entier $n$ s'encode en $\mc{O}(\log_2(n))$, taille de l'écriture binaire.\\
    Une complexité en $\mc{O}(n)$ où $n$ est l'entier en entrée, est donc exponentielle pour un algorithme dont l'entrée est $n$, est $\mc{O}(n) = \mc{O}(2^{\log_2(n)})$. C'est donc exponentiel en la taille de l'entrée !
\end{exemple}

\begin{remarque}{}{relative aux problèmes}
    Selon l'importance des entiers dans le problème, on peut "ignorer" que les entier prennent beaucoup de place~:
    \begin{itemize}
        \item pour un graphe pondéré, la taille des entiers est ignorée.
        \item pour le problème du sac à dos, la taille des entiers est prise en compte.
    \end{itemize}
\end{remarque}

\begin{exemple}{}{}
    \begin{itemize}
        \item \textbf{Instance} : un entier $n$
        \item \textbf{Question} : $v_2(n) \geq v_3(n)$ ? (en parlant de valuation $2$-adique)
    \end{itemize}
    \begin{lstLNat}
    Algo($n$):
        tmp = $n$
        tant que tmp%2 == 0 ou tmp%3==0:
            si tmp%6==0:
                tmp = tmp/6
            sinon si tmp%2==0:
                renvoyer Vrai
            sinon si tmp%3==0:
                renvoyer Faux
        renvoyer Vrai // $v_2(n) = v_3(n)$
    \end{lstLNat}
    La complexité temporelle est en $\mc{O}(\log_6(n)) = \mc{O}(\log_2(n)) = \mc{O}(\abs{n})$. C'est une complexité linéaire en la taille de l'entrée~: $\abs{n} = \log_2(n)$.\\\\
    Moralité : toujours se ramener à une complexité en fonction de la taille de l'entrée.
\end{exemple}

\begin{remarque}{}{}
    La taille de l'entrée est à rapprocher de la taille du mot de $\Sigma = \{0;1\}$ que l'on écrit initialement sur une machine de Turing exécutant l'algorithme sur ce mot.
\end{remarque}

\subsection{Classe P}

\begin{definition}{}{classe P}
    On appelle \notion{classe P} (ou \notion{classe PTIME}) l'ensemble de \notion{problèmes de décision} que l'on peut résoudre à l'aide d'un algorithme de complexité polynomiale en la taille de l'entrée (pour un choix d'encodage).
\end{definition}

\begin{remarque}{}{}
    Généralement, on donne la complexité sous la forme $\mc{O}(\abs{e}^k)$ avec $k$ un entier (degré de l'expression polynomiale de la complexité) et $\abs{e}$ désignant la taille de l'entier.
\end{remarque}

\begin{remarque}{}{}
    Les problèmes de la classe P sont raisonnablement traitables. (Attention, on parle toujours uniquement de problème de décision).\\
    Pour considérer des problèmes d'optimisation, on se ramène à des problèmes de décision en introduisant un seuil à dépasser pour la fonction de coût.
\end{remarque}

\begin{remarque}{}{classe EXP}
    La \notion{classe EXP} (ou \notion{classe EXPTIME}) est la classe de problèmes de décision pour lesquels il existe un algorithme de résolution de complexité exponentielle~:
    $$\mc{O}\Big(P(\abs{e})\exp(\abs{e})\Big)$$
    où $P$ est un polynôme réel et $\abs{e}$ est la taille de l'entrée.
\end{remarque}

\begin{remarque}{}{comparaison entre EXP et P}
    On a P $\subset$ EXP car $e^n \gg P(n)$ pour $n \to +\infty$.
\end{remarque}

\begin{remarque}{}{}
    La complexité, soit le nombre d'opérations élémentaires, dépend du modèle de calcul choisi. Il en existe plusieurs.\\
    En MPI, on se place dans le cadre d'un modèle de calcul intuitif, qui correspond au fonctionnement d'un ordinateur exécutant un programmation en C ou en OCaml. Les opérations élémentaires sont alors les suivantes~:
    \begin{itemize}
        \item écriture
        \item lecture
        \item opération arithmétique
        \item etc (cf MP2I)
    \end{itemize}
    De plus on fait l'hypothèse que la machine dispose d'une \notion{mémoire infinie}~:
    \begin{itemize}
        \item la pile d'appels ne déborde jamais
        \item il n'y a pas de limite à la quantité de données allouable sur la pile, le tas ou bien le segment de données.
    \end{itemize}
    Un autre modèle de calcul classique est celui des machines de Turing~: on compte le nombre de transitions empruntées au cours d'un calcul.
\end{remarque}

\begin{exemple}{}{problème du dernier exemple}
    Le problème précédent (valuations) est de classe $P$ car linéaire et particulier polynomial.
\end{exemple}

\begin{exemple}{}{problème \deuxsat}
    \begin{itemize}
        \item \textbf{Instance}~: $\varphi$ une formule de la logique propositionnelle sous forme normale conjonctive dont les clauses sont de taille au plus 2.
        \item \textbf{Question}~: $\varphi$ est-elle satisfiable ?
    \end{itemize}
    On a \deuxsat $\in$ P. En effet, on peut construire le graphe d'implications puis lui appliquer l'algorithme de Kosaraju qui renvoie les composantes fortement connexes du graphe d'implications. On vérifie que pour $x \in \mc{V}_\varphi$, $x$ et $\lnot x$ ne sont pas dans la même composante fortement connexe. $\varphi = C_1 \wedge \dots \wedge C_k$ de taille $\mc{O}(k) = \abs{\varphi}$.\\\\
    \notion{Construction du graphe}~:
    \begin{itemize}
        \item au plus $4k$ sommets (un par littéral)
        \item au plus $2k$ arêtes (deux par clause)
    \end{itemize}
    se fait en $\mc{O}(k)$\\
    Kosaraju  : $\mc{O(\abs{A} + \abs{S})}$ (deux parcours), se fait en 

    à finir
\end{exemple}

\subsection{Classe NP}

\begin{definition}{}{}
    Pour un problème de décision, on appelle \notion{certificat} une donnée que l'on peut ajouter à l'entrée permettant de vérifier que l'entrée est une instance positive.
\end{definition}

\begin{exemple}{}{}
    Pour le problème \sat, la donnée d'une valuation est un certificat. En effet, on vérifie que la valuation satisfait la formule pour vérifier qu'elle est satisfiable donc que c'est une instance positive.
    Pour toute formule $\varphi$, il existe une valuation $v$ telle que l'algorithme vérificateur confirme que $\varphi$ est satisfiable est satisfable.
\end{exemple}

\begin{exemple}{}{lié au problème K-COLOR}
    \begin{itemize}
        \item \textbf{Instance}~: $G=(S,A)$ un graphe, $k \in \N$.
        \item \textbf{Question}~: sur l'existence de $c:S\to \intint{1}{k}$ un coloriage des sommets à $k$ couleurs tel que~:
        $$\forall (u,v) \in A,\, c(u) \neq c(v)$$
    \end{itemize}
    On peut chosiir la donnée d'une fonction $c:S\to\intint{1}{k}$ comme certificat.
\end{exemple}

\begin{definition}{}{classe NP}
    La classe NP est l'ensemble des problèmes de décision pour lesquels il existe un \notion{algorithme vérificateur} permettant de \notion{vérifier} qu'une instance est positive à partir d'un couple (instance, certificat) en temps polynomial en la taille de l'instance, avec un certificat de taille polynomiale en fonction de cette taille.
\end{definition}

\begin{exemple}{}{problème \sat}
    Soit $\varphi$ une instance positive (une formule satisfiable) et $v$ un certificat associé à $\varphi$ (un modèle de $\varphi$)~:
    $$\abs{v} = \abs{\mc{V}_\varphi} = \abs{\varphi}$$
    L'algorithme vérificateur repose sur un parcours de l'arbre représentant $\varphi$ en $\mc{O}\Big(\abs{\varphi}\Big)$
\end{exemple}

\begin{remarque}{}{}
    L'algorithme vérificateur prend en entrée~:
    \begin{itemize}
        \item un encodage de l'instance
        \item un encodage du certificat
    \end{itemize}
    deux chaînes de caractères ! Si on choisit un certificat booléen, pour un instance $i^+$ positive, on note \code{verif} l'algorithme tel que~:
    \begin{itemize}
        \item \code{verif($i^+$,true)} renvoie \code{true}
        \item \code{verif($i^+$,false)} renvoie un booléen arbitraire
    \end{itemize}
    et pour $i^-$ une instance négative~:
    \begin{itemize}
        \item \code{verif($i^-$,true)} renvoie \code{false}
        \item \code{verif($i^-$,false)} renvoie \code{false}
    \end{itemize}
    Si on a un tel algorithme, alors on sait résoudre le problème avec cet algorithme et le certificat n'est pas nécessaire. Donc on ne pas prendre directement la solution comme un certificat ? 
    A montrer à ChatGPT, il saura m'expliquer.
\end{remarque}

\begin{remarque}{}{sur la définition}
    Pour tout instance positive, l'algorithme vérificateur doit renvoyer Vrai pour l'instance accompagnée d'un certificat valide en temps polynomial en la taille de l'entrée.\\\\
    Pour toute instance négative, l'algorithme vérificateur doit renvoyer Faux pour cette instance, quel que soit le certificat qui l'accompagne.
\end{remarque}

\begin{definition}{}{formelle de classe NP}
    Soit $\mc{P}$ un problème de décision défini par sa fonction de prédicat $f: I \to \{Vrai, Faux\}$. $\mc{P}$ est de classe NP lorsqu'il existe~:
    \begin{enumeratebf}
        \item $\Sigma$ un alphabet permettant d'encoder un ensemble $C$ de certificats
        \item $\mc{P}'$ un problème de prédicat~:
        $$f': I\times \Sigma^* \to  S=\{Vrai, Faux\}$$
        \item $g : I_1 \to I_2$ une fonction polynomiale telle que pour tout $e\in I$, $f(e)$ est Vrai ssi~:
        $$\exists c \in C,\, \abs{c} \leq g(\code{e}) \quad \text{et} \quad f'(e,\abs{c}) = Vrai$$
        ($\abs{\cdot}$ désigne la taille de représentation)
        \item le problème $\mc{P}'$ est dans $\mc{P}$.
    \end{enumeratebf}
    L'algorithme en temps polynomial qui résout $\mc{P}'$ est appelé \notion{algorithme vérificateur}.
\end{definition}

\begin{remarque}{}{sur la définition}
    Dans la 3. : $\abs{c} \leq g(\abs{e})$ signifie que le certificat est de taille polynomiale en fonction de la taille de l'instance.
\end{remarque}

\begin{remarque}{}{}
    Pour montrer en pratique qu'un problème est dans NP~:
    \begin{itemize}
        \item on exhibe un certificat de taille polynomiale en fonction de l'instance
        \item on donne un algorithme vérificateur de complexité polynomiale en fonction de l'instance.
    \end{itemize}
\end{remarque}

\begin{exemple}{}{}
    On considère le problème CYCLE HAMILTONIEN~:
    \begin{itemize}
        \item \textbf{Instance}~: $G=(S,A)$ un graphe
        \item \textbf{Question}~: Existe-t-il un cycle passant exactement par tous les sommets de $S$ ?
        \item \textbf{Certificat}~: une permutation $\sigma$ de $S$.
    \end{itemize}
    \begin{lstLNat}
    VERIFICATEUR($G$,$\sigma$):
        n = $\abs{S}$
        vérifier que $\sigma$ est dans $\mc{S}_n$.
        pour i=1 jusqu'à n-1:
            Si $\Big(\sigma(i),\sigma(i+1)\Big) \notin A$:
                renvoyer false
        renvoyer ($\Big(\sigma(n),\sigma(1)\Big) \in A$)
    \end{lstLNat}
    Cet algorithme est de complexité en $\mc{O(\abs{S})}$ donc en temps polynomial en fonction de la taille de $G$ en mémoire : $\abs{S} + \abs{A}$ et $\abs{\sigma} = \abs{S}$ également polynomiale.
\end{exemple}

\begin{proposition}{}{classe P implique classe NP}
    P $\subset$ NP.
\end{proposition}

\begin{demonstration}
    On peut prendre n'importe quel certificat, on utilise l'algorithme résolvant $\pbm$ en temps polynomial comme algorithme vérificateur.
\end{demonstration}

\begin{remarque}{}{sens réciproque}
    Le sens réciproque est un problème ouvert. On ne connaît aucun exemple de problème de classe NP pour lequel on a une démonstration du fait qu'il n'est pas de classe P.
\end{remarque}

\subsection{Le problème d'optimisation}
Pour étudier la classe de complexité d'un problème d'opitimisation , one le transforme en problème de décision en ajoutant un \notion{seuil} à l'entrée. On répond alors à la question~:\\
"Existe-t-il une solution réalisable dont la valeur atteinte par la fonction de coût est supérieur (maximisation) ou inférieur (minimisation) à un seuil $s$ ?"\\\\

Le problème de décision associé est "moins compliqué". En particulier, si pour le problème de décision, on ne sait pas trouver d'algorithme en temps polynomial, on ne saura pas non plus pour le problème d'optimisation~: il est légitime de s'intéresse à des \notion{algorithmes d'approximation}.

\begin{remarque}{}{}
    Si le problème de décision est de classe P, on peut s'approcher le plus possible de la valeur optimale par dichotomie en utilisant plusieurs appels à l'algorithme de résolution en temps polynomial.
\end{remarque}
On introduit la notation hors programme suivante.\\
La classe des problèmes d'optimisation dont le problème de décision associé est de classe P s'appelle la classe PO.
De même, pour la classe NP, la classe NPO.

\section{Réduction polynomiale}


\begin{definition}{}{réduction polynomiale}
    Soit deux problèmes de décision $\pbm_1$ et $\pbm_2$ définis par $f_1$ et $f_2$ leurs fonctions de prédicats associées définies sur un $I_1$ et $I_2$ respectivement. On dit que \notion{$\pbm_1$ se réduit à $\pbm_2$ de façon polynomiale} (noté $\pbm_1 \reductibleP \pbm_2$) lorsqu'il existe $g:I_1 \to I_2$ calculable avec un algorithme de complexité polynomiale telle que~:
    $$\forall e \in I_1,\, f_1(e) = f_2\Big(g(e)\Big)$$
\end{definition}

\begin{remarque}{}{}
    On a la même définition de réduction many-to-one que lorsqu'on discute de décidabilité, on uniquement l'hypothèse supplémentaire de l'existence d'un algorithme polynomial qui transforme les instances de $\pbm_1$ en des instances de $\pbm_2$.
\end{remarque}

\begin{proposition}{}{$\reductibleP$ est presque une relation d'ordre}
    La relation $\reductibleP$ est réflexive, transitive, mais non antisymétrique.
\end{proposition}
Voir démo 1

\begin{proposition}{}{}
    Soit $\pbm_1$ et $\pbm_2$ deux problèmes de décision. Si $\pbm_1 \reductibleP \pbm_2$ et $\pbm_2$ est de classe P, alors $\pbm_1$ est de classe P.
\end{proposition}

\begin{demonstration}
    Il suffit de combiner l'algorithme calculant $g$ et l'algorithme qui résout $\pbm_2$ en temps polynomial.
\end{demonstration}

Voir suite par Gwénolé.

\section{NP-completude, NP-difficile}

\subsection{Définitions et problème \sat}

\begin{definition}{}{}
    Un problème de décision est \notion{NP-difficile} ou \notion{NP-dur} lorsqu'il est possible de se ramener à tout problème de classe NP par une réduction polynomiale depuis ce problème.\\
    Moralement, il est plus difficile que tous les problèmes NP, mais on peut s'y ramener.
\end{definition}

\begin{definition}{}{}
    Soit $\pbm$ un problème de décision. $\mc{P}$ est NP-difficile si et seulement si~:
    $$\forall \mc{P}' \in \mr{NP},\, \mc{P}' \reductibleP \mc{P}$$
    Si de plus $\mc{P}$ est dans NP, alors $\mc{P}$ est \notion{NP-complet}.
\end{definition}

\begin{remarque}{}{}
    Pour montrer qu'un problème est NP-diffficile, on montre que \sat se réduit polynomialement à ce problème~: $\mr{\sat} \reductibleP \pbm$.
    On utilise donc la transitivité de $\reductibleP$.
\end{remarque}

\subsection{Rédution polynomiale et NP-difficulté}


\begin{proposition}{}{}
    Soit $\pbm_1$ et $\pbm_2$ deux prolbèmes de décision. Si $\pbm_1 \reductibleP \pbm_2$ et $\pbm_1$ est NP-difficile, alors $\pbm_2$ est NP-difficile.
\end{proposition}

\begin{demonstration}
    $\reductibleP$ est une relation transitive. On va l'utiliser. On a~:
    $$ \begin{cases*}
        \forall \pbm \in NP,\,\pbm \reductibleP \pbm_1\\
        \pbm_1 \reductibleP \pbm_2
    \end{cases*} $$
    Par transitivité,
    $$\forall \pbm \in NP,\,\pbm \reductibleP \pbm_2$$
    $\pbm_2$ est bien NP-difficile.
\end{demonstration}

\begin{remarque}{}{}
    Pour montrer qu'un problème $\pbm$ est NP-complet~:
    \begin{itemize}
        \item on montre qu'il est de classe NP  l'aide d'un certificat et d'un algorithme vérificateur.
        \item On choisit un problème $\pbm_ref$ de référence (\sat, FNC-\sat/\cnfsat ou \troissat sont permis), et on montre que $\pbm_ref \reductibleP \pbm$.
    \end{itemize}
\end{remarque}

\subsection{Exemple du problème FNC-\sat ou \cnfsat}

\begin{definition}{}{problème \cnfsat}
    \begin{itemize}
        \item \textbf{Instance} : $\varphi$ une formule de la logique propositionnelle sous forme normale conjonctive (FNC)
        \item \textbf{Question} : Est-ce que $\varphi$ est satisfiable ?
    \end{itemize}
\end{definition}

\begin{proposition}{}{}
    CNF est NP-complet.
\end{proposition}

\begin{remarque}{}{}
    Utilisable sans rappel au concours. (on l'a dit avant, c'est le cas pour trois problèmes)
\end{remarque}

\begin{demonstration}
    Par étapes habituelles. La méthode suivie est décrite en \textit{italique}.
    Montrons que \cnfsat est de classe NP.\\
    On choisit comme ensemble de certificats l'ensemble des valuations. \textit{Justifions que pour une instance positive au problème, il existe un certificat}. Pour une formule $\varphi$ satisfiable, il existe $v_\varphi$ un modèle de $\varphi$ sur $\mc{V}_\varphi$ l'ensemble des variables que $\varphi$ comporte. $v_\varphi$ est de taille en $\mc{O}(\abs{\varphi})$.\\\\
    Un algorithme vérificateur : on parcourt l'arbre de la formule en utilisant la valuation pour obtenir les valeurs de vérité pour les variables et on procède récursivement. Moralement, on regarde si la valuation est un modèle.
    \begin{lstOCaml}
        type formule =  X of int | Not of formule | Or of formule*formule 
        | And of formule*formule | Top | Bot

        let rec verifie f (v:bool array) = 
            match f with
            | X (i) -> v.(i)
            | Top -> true
            | Bot -> false
            | Or (f1, f2) -> (verifie f1 v) || (verifie f2 v)
            | And (f1, f2) -> (verifie f1 v) && (verifie f2 v)
            | Not f1 -> not (verifie f1 v)
    \end{lstOCaml}
\end{demonstration}

\begin{demonstration}
    Montrons que $\sat \reductibleP \cnfsat$\\\\
    On doit définir une fonction $g$ qui transforme une instance $\varphi$ de \sat en une instance de \cnfsat $g(\varphi)$ telle que~:
    $$\varphi \text{ satisfiable } \Leftrightarrow g(\varphi) \text{ satifiable}$$
    On décrit un algorithme permettant de passer de $\varphi$ à $g(\varphi)$~:
    \begin{enumeratebf}
        \item On élimine tous les connecteurs $\rightarrow$ et $\leftrightarrow$ en appliquant les équivalences~:
        $$\begin{cases*}
            \varphi_1 \rightarrow \varphi_2 \equiv \lnot \varphi_1 \vee \varphi_2\\
            \varphi_1 \leftrightarrow \varphi_2 (\lnot \varphi_1 \vee \varphi_2) \wedge (\lnot \varphi_2 \vee \varphi_1)
        \end{cases*}$$
        Cela s'effectue en $\mc{O}(\abs{\varphi})$, si on considère que la suppression des $\leftrightarrow$ ne duplique pas réellement les variables $\varphi_1$ et $\varphi_2$ (avec des pointeurs par exemple).
        \item On applique ensuite les lois de De Morgan~:
    \begin{lstOCaml}
    let rec morgan phi =
        match phi with
        | Not (And (phi1, phi2)) -> Or (morgan (Not phi1), morgan (Not phi2))
        | Not (Or (phi1, phi2)) -> And (morgan (Not phi1), morgan (Not phi2))
        | Not (Top) -> Bot
        | Not (Bot) -> Top
        | Not (Not phi1) -> morgan phi1
        | And (phi1, phi2) -> And (morgan phi1, morgan phi2)
        | Or (phi1, phi2) -> Or (morgan phi1, morgan phi2)
        | _ -> phi
    \end{lstOCaml}
    Cela s'effectue en $\mc{O}(\abs{\varphi})$. On obtient à l'issue une forme normale négative ($\lnot$ uniquement permis devant des variables seules, et uniquement $\wedge$ et $\vee$).
    \item  À partir de $\hat{\varphi}$ la formule obtenue à l'étape 2, on construit inductivement $g(\varphi)$. On transforme donc une forme normale négative $f = \hat{\varphi}$ en une forme normale conjonctive $F$.
    \begin{itemize}
        \item Cas de base~: $f$ est un littéral $\top$ ou $\bot$, on pose $F = f$
        \item Cas inductifs~:
        \begin{itemize}
            \item $f = f_1 \wedge f_2$. On construit $F_1$ et $F_2$ à partir de $f_1$ et $f_2$. On pose $F = F_1 \wedge F_2$.
            \item $f = f_1 \vee f_2$. Ça se complique. On construit inductivement $F_1$ et $F_2$, à partir de $f_1$ et $f_2$. On pose $F' = (F_1 \vee y) \wedge (F_2 \vee \lnot y)$ avec $g$ qui n'apparait pas dans $F_1$ et $F_2$.\\
            $F'$ n'est pass une FNC. On la transforme en $F$ en distribuant les littéraux $y$ et $\lnot y$ dans toutes les clauses de $F_1$ et $F_2$ (resp.).
        \end{itemize}
    \end{itemize}
    \end{enumeratebf}
\end{demonstration}

\begin{demonstration}
    On a alors $F = g(\varphi)$. Montrons que $f$ est satisfiable si et seulement si $F$ est satisfiable. Évidemment, on n'a pas directement $F = f$. On pose $\mc{V}_F$ les vriables de $F$, pareil pour$f$. On a $\mc{V}_f \subset \mc{V}_F$. On va montrer que
    \begin{itemize}
        \item $\mr{Mod}(F) \subset \mr{Mod}(f)$ si on restreint aux variables de $f$ les modèles.
        \item $\mr{Mod}(f) \subset \mr{Mod}(F)$ si on prolonge aux variables de $F$ les modèles.
    \end{itemize}
    On procède par induction~: LE DEBUT EST MANQUANT
    \begin{itemize}
        \item Cas de base~: $F = f$, donc on a $v$ ....
        \item \begin{itemize}
            \item $f = f_1 \vee f_2$. On construit encore $F$ via $F' = (F_1 \vee y) \wedge (F_2 \vee \lnot y)$ en distribuant. Soit $v$ un modèle de $F$, c'est un modèle de $F'$.
            \begin{itemize}
                \item Si $v(y) = F$, nécessairement, $v$ est un modèle de $F_1$ pour satisfaire $(F_1 \vee y)$. Par hypothèse d'induction, $v_{|v_f}$ modèle de $f_1$. Donc modèle de $f$.
                \item Si $v(y) = V$, le cas est symétrique.
            \end{itemize}
            Soit $v$ un modèle de $f$.
            \begin{itemize}
                \item si $v$ est un modèle de $f_1$, alors par hypothèse d'induction, on peut prolonger $v$ en $v_1$ modèle de $F_1$. On pose alors $\widetilde{v} : y \mapsto F; x \mapsto v_1(x)$ pour $x \neq y$.
                \item si $v$ est un modèle de $f_2$, le cas est symétrique.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    Il reste à justifier que 
\end{demonstration}

Photos du vendredi 07/03 à recopier ici.

Récapulatif
\begin{proposition}{}{}
    \troissat est un problème NP-complet
\end{proposition}

\begin{demonstration}
    \textbf{Etape 1} : \troissat est de classe NP (\textit{algo vérificateur} avec une valuation comme \textit{certificat} en temps \textit{polynomial}) (les mots-clés sont en italique)\\
    \textbf{Etape 2} : montrer que $\cnfsat \reductibleP \troissat$.\\
    L'idée est la suivante. Convertir $(l_1 \vee \dots \vee l_k)$ en $(l_1 \vee l_2 \vee x_{2,3})\wedge(\lnot x_{2,3} \vee l_3 \vee x_{3,4})$.\\
    On définit une fonction $g$ qui prend une formule $\varphi$ sous FNC (instance de \cnfsat) et construit une instance de \troissat $g(\varphi)$ qui vérifie~:
    $$\varphi \text{ satisfiable } \Longleftrightarrow g(\varphi) \text{ satisfiable }$$
    Soit $\varphi$ une telle FNC, qu'on écrit~:
    $$\varphi = \bigwedge_{i=1}^n C_i$$
    Pour $i \in \intint{1}{n}$, on construit la formule~:
    $$F_i = \begin{cases*}
        C_i &si $C_i$ est de taille au plus 3.\\
        h(C_i) &sinon
    \end{cases*}$$
    où $h(C_i)$, pour $C_i = (l_{1,i} \vee \dots \vee l_{k,i})$ ($k \geq 4$), on introduit $k-3$ variables propositionnelles spécifiques à la clause (non déjà présente dans $\mc{V}_\varphi$), notées $(x_{j,j+1,i})_{j \in \intint{2}{k-2}}$. Ainsi~:
    $$F_i = (l_{1,i} \vee l_{2,i} \vee x_{2,3,i}) \wedge (\lnot x_{2,3,i} \vee l_{3,i} \vee x_{3,4,i}) \wedge \dots \wedge (\lnot x_{k-2, k-1, i}\vee l_{k-1,i} \vee l_{k,i})$$
    Ainsi, $\abs{F_i} = \mc{O}(\abs{C_i})$ (on triple la taille).\\
    On pose alors~:
    $$g(\varphi) = \bigwedge_{i=1}^nF_i$$
    Les $F_i$ sont toutes des 3-FNC donc $g(\varphi)$ est une 3-FNC. De plus, $\abs{g(\varphi)} = \mc{O}(\abs{\varphi})$ et est constructible en temps linéaire.
\end{demonstration}

\begin{demonstration}
    Il reste à montrer que~:
    $$\varphi \text{ satisfiable } \Longleftrightarrow g(\varphi) \text{ satisfiable }$$

    \begin{itemize}
        \item $\boxed{\implies}$ : Si $\varphi$ est satisfiable, soit $v$ un modèle de $\varphi$. On souhaite le prolonger sur les nouvelles variables en $\widetilde{v}$ de sorte que $\widetilde{v}$ satisfasse $g(\varphi)$.\\
        On considère une clause $C_i$~:
        \begin{itemize}
            \item Si $F_i = C_i$, $v$ convient déjà
            \item Si $F_i \neq C_i$, écrivons $C_i = (l_{1,i}\vee \dots l_{k,i})$.\\
        \end{itemize}
        $v$ satisfait $C_i$ donc $v$ satisfait un littéral $l_{j,i}$ parmi ceux-là. Dans $F_i$, voir Figure 100.\\
        On peut prolonger $v$ en posant~:
        $$\widetilde{v}(x_{p,p+1,i}) = \begin{cases*}
            V &si $p \leq j-1$\\
            F &sinon
        \end{cases*}$$
        $\widetilde{v}$ satisfait bien $F_i$.
        On applique cela pour tous les $F_i$ et comme les variables sont spécifiques à une clause, il n'y a pas de contradiction (au sens doublon de variable). $\widetilde{v}$ satisfait $g(\varphi)$. Donc $g(\varphi)$ est satisfiable.
        \item $\boxed{\impliedby}$ : Supposons que $g(\varphi)$ satisfiable.\\
        Soit $v$ un modèle de $g(\varphi)$. Montrons que $v$ satisfait $\varphi$ (même s'il est défini sur plus que $\mc{V}_\varphi$).\\
        On considère une clause $C_i$~:
        \begin{itemize}
            \item Si $F_i = C_i$, $v$ satisfait $F_i$ donc $C_i$
            \item Si $F_i \neq C_i$, notons~:
            \begin{align*}
                F_i =& (l_{1,i} \vee l_{2,i} \vee x_{2,3,i}) \wedge \\
                 &\dots \wedge\\
                 & (\lnot x_{j, j+1,i} \vee l_{j+1,i} \vee x_{j+1,j+2,i}) \wedge\\
                 &\dots \wedge\\
                 & (\lnot x_{k-2, k-1,i} \vee l_{k-1,i} \vee l_{k,i})
            \end{align*}
            Supposons par l'absurde que $v$ ne satisfait aucun $l(j,i)$.\\
            La première clause est satisfaite donc $v(x_{2,3,i}) = V$ nécessairement. Par propagation de clause en clause, on a $v(x{j,j+1,i}) = V$ pour tout $j$, et la dernière clause ne peut être satisfaite dans ces conditions. absurde.\\
            $v$ satisfait donc au moins un littéral $l_i$ donc la clause $C_i$.\\\\
            Au totale, $v$ satisfait toutes les clauses de $\varphi$, qui est donc satisfiable.\\
        \end{itemize}
        Donc $g$ est bien une réduction polynomiale~:
        $$\cnfsat \reductibleP \troissat$$
        Puis $\cnfsat$ est NP-complet. Ainsi $\troissat$ est NP-difficle.
    \end{itemize}
    Au total avec ces deux tirets principaux, on a bien que $\troissat$ est NP-complet.
\end{demonstration}

\subsection{Chemin hamiltonien}

\begin{definition}{}{chemin hamiltonien}
    Dans un graphe $G = (S,A)$, un \notion{chemin hamiltonien} de $s\in S$ à $t \in S$ est un chemin de départ $s$, d'arrivée $t$ passant exactement une fois par chacun des sommets de $S$.
\end{definition}

\begin{definition}{}{cycle hamiltonien}
    Dans un graphe $G = (S,A)$, un \notion{cycle hamiltonien} est un chemin hamiltonien d'origine et d'extrémité égales.
\end{definition}

On définit deux problèmes

\begin{definition}{}{Problème \cheminham}
    \textbf{Instance} : Un graphe $G=(S,A)$ orienté, $s$ et $t$ deux sommets de $S$.
    \textbf{Question} : Existe-t-il un chemin hamiltonien de $s$ à $t$ ?
\end{definition}

\begin{definition}{}{Problème \cycleham}
    \textbf{Instance} : Un graphe $G=(S,A)$ orienté
    \textbf{Question} : Existe-t-il un cycle hamiltonien dans $G$?
\end{definition}

\begin{proposition}{}{concernant ces deux problèmes}
    \cheminham et \cycleham sont NP-Complets.
\end{proposition}

\begin{demonstration}
    Les mots-clés sont en italique.
    \begin{itemize}
        \item Montrons qu'ils sont de classe NP. On choisit comme ensemble des \textit{certificats} les suites des sommets.\\
        On peut construire un \textit{algorithme vérificateur} de complexité en la taille de la liste des sommets qui vérifie que chaque sommet du graphe apparaît une et une seule fois (avec un tableau de booléens), qu'il y a bien des arêtes entre deux sommets consécutifs (cela se fait en $\mc{O}(1)$ avec des matrices d'adjacence) et éventuellement que l'on a le bon départ, la bonne arrivée.\\
        Moralement, on vérifie que c'est bien un cycle hamiltonien ou un chemin hamiltonien.\\
        Pour une instance positive, il existe un bon certificat de taille $\abs{S}$ qui permet de renvoyer Vrai avec l'algorithme vérificateur en \textit{temps polynomial}.\\
        Pour une instance négative, l'algorihtme renvoie bien sûr toujours faux.
        \item Montrons maintenant que $\troissat \reductibleP \cycleham$ et $\troissat \reductibleP \cheminham$.\\
        Pour $\varphi$ une 3-FNC, on cherche à construire le graphe $G_\varphi$ tel que~:
        $$\varphi \in \troissat^+ \Longleftrightarrow (G_\varphi,s,t) \in \cheminham^+$$
        $\troissat^+$ est l'ensemble des instances positives du problème \troissat. \\
        De même on cherche un graphe $G_{\varphi'}$ tel que~:
        $$\varphi \in \troissat^+ \Longleftrightarrow G_{\varphi'} \in \cycleham^+$$
        $G_\varphi$ et $G_{\varphi'}$ doivent être de taille polynomiale en $\abs{\varphi}$ et constructible en temps polynomial.\\
        On pose~:
            $$\varphi = \bigwedge_{i=1}^kC_i$$
        Avec pour $i \in \intint{1}{k}$, $C_i = (l_{1,i} \vee l_{2,i} \vee l_{3,i})$
        On pose le graphe gadget suivant~: (Figure 101).\\
        Ce graphe gadget a la particularité de présenter exactement deux chemins hamiltoniens de $s$ à $t$~:
        \begin{itemize}
            \item $s \rightarrow g \rightarrow \dots \rightarrow d \rightarrow t$
            \item $s \rightarrow d \rightarrow \dots \rightarrow g \rightarrow t$
        \end{itemize}
    \end{itemize}
\end{demonstration}

\begin{demonstration}
        On pose alors $\mc{V}_\varphi = \{x_1, \dots, x_n\}$ l'ensemble des variables qui vont apparaître dans $\varphi$.\\
        On construit le graphe $G_{\mc{V}_\varphi}$ en utilisant $n$ fois ce graphe gadget : une fois pour chaque variable ! (Voir figure 102).\\
        $G_{v_\varphi}$ a exactement $2^n$ chemins hamiltoniens (deux possibilités à chaque fois) de $s$ à $t$, auxquels on peut faire correspondre une valuation du $\mc{V}_\varphi$.\\
        À un chemin hamiltonien de $s$ à $t$, on fait correspondre une valuation $v$ telle que pour $i \intint{1}{n}$~:
        $$v(x_i)  = \begin{cases*}
            V &si $g_i$ apparaît avant $d_i$ dans le chemin hamiltonien\\
            F &sinon
        \end{cases*}$$
        Pour chaque classe $C_j$, on rajoute un sommet en fonction des cas, comme dans la figure 103.\\
        On obtient un graphe $G_\varphi = (S_\varphi, A_\varphi)$, avec~:
        $$\begin{cases*}
            \abs{S_\varphi} = \underbrace{k}_{\text{clauses}} + \underbrace{2}_{s,t} + n\underbrace{(2k+4)}_\text{gadget} &bien polynomiale en $\abs{\varphi}$\\
            \abs{A_\varphi} \leq \underbrace{(2k+3)}_\text{gadget}2n + \underbrace{n + 1}_{\text{lien entre les gadget}} + \underbrace{6k}_{\text{clauses}} &polynomiale en $\abs{\varphi}$.
        \end{cases*}$$
        $G_\varphi$ est bien constructible en temps polynomial.\\
        On construit $G_{\varphi'}$ à partir de $G_\varphi$ en rajoutant une arête de $t$ à $s$. \textbf{C'est la seule chose qui les sépare, d'où l'intérêt de factoriser les démos} Montrons que~:
        \begin{align*}
            &\varphi \in \troissat^+\\
            \Longleftrightarrow \quad &(G_\varphi,s,t) \in \cheminham^+\\
            \Longleftrightarrow \quad &G_{\varphi'} \in \cycleham^+
        \end{align*}
        On doit la dernière équivalence au fait que $(t,s)$ est nécessaire dans le cycle. On montre la première.
        \begin{itemize}
            \item $\boxed{\implies}$ : Si $\varphi$ est satisfiable, soit $v$ un modèle de $\varphi$. On s'intéresse au chemin hamiltonien dans $G_{v_\varphi}$.\\
            Pour chaque clause $C_j$, on a au moins un littéral satisfait, on transforme le chemin hamiltonien dans $G_{v_\varphi}$ en chemin hamiltonien dans $G_\varphi$ en prenant le détour vers $C_j$ correspondant au littéral satisfait.
            \item Si $(G_\varphi, s, t) \in \cheminham^+$, on considère la valuation correspondant au chemin hamiltonien existant. on a au moins un détour pris par clause donc chacune est satisfiable.
        \end{itemize}
\end{demonstration}


\end{document}