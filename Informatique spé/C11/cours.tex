\input{../../stock/en-tete_v4.tex}
\begin{document}
\begin{adjustwidth}{-3cm}{-3cm}
\input{../../stock/commands.tex}
\newcounter{chapitre}
\setcounter{chapitre}{11}
\title{Classes de complexité}
\maketitle
\section{Classes de complexité pour un problème de décision}
\subsection{Complexité}

\newcommand{\pbm}[]{\mc{P}}

\begin{definition}{}{}
    Soit $\mc{P}$ un problème abstrait défini par une fonction $f:I\to S$. On considère un algorithme $\mc{A}$ "abstrait" qui le résout.\\
    On y associe un problème \notion{concret} en imposant des choix sur \notion{l'encodage} des entrées et des sorties.\\
    La \notion{complexité du problème concret} correspond à la complexité de l'implémentation de l'algorithme $\algo$ (sa réalisation concrète) pour le choix d'encodage.\\
    C'est-à-dire un ordre de grandeur du nombre d'opérations élémentaires réalisées par l'implémentation de l'algorithme pour une entrée en fonction de la \notion{taille de l'entrée} (espace occupé en mémoire pour son encodage).
\end{definition}

\begin{remarque}{}{cas du graphe}
    La taille de l'encodage pour un graphe~:
    \begin{itemize}
        \item matrice d'adjacence~: $\mc{O}(\abs{S}^2)$
        \item liste d'adjacence~: $\mc{O}(\abs{S} + \abs{A})$
    \end{itemize}
\end{remarque}

\begin{exemple}{}{taille de l'endage des entiers}
    Un entier $n$ s'encode en $\mc{O}(\log_2(n))$, taille de l'écriture binaire.\\
    Une complexité en $\mc{O}(n)$ où $n$ est l'entier en entrée, est donc exponentielle pour un algorithme dont l'entrée est $n$, est $\mc{O}(n) = \mc{O}(2^{\log_2(n)})$. C'est donc exponentiel en la taille de l'entrée !
\end{exemple}

\begin{remarque}{}{relative aux problèmes}
    Selon l'importance des entiers dans le problème, on peut "ignorer" qe les entier prennent beaucoup de place~:
    \begin{itemize}
        \item pour un graphe pondéré, la taille des entiers est ignorée.
        \item pour le problème du sac à dos, la taille des entiers est prise en compte.
    \end{itemize}
\end{remarque}

\begin{exemple}{}{}
    \begin{itemize}
        \item \textbf{Instance} : un entier $n$
        \item \textbf{Question} : $v_2(n) \geq v_3(n)$ ? (en parlant de valuation $2$-adique)
    \end{itemize}
    \begin{lstLNat}
    Algo($n$):
        tmp = $n$
        tant que tmp%2 == 0 ou tmp%3==0:
            si tmp%6==0:
                tmp = tmp/6
            sinon si tmp%2==0:
                renvoyer Vrai
            sinon si tmp%3==0:
                renvoyer Faux
        renvoyer Vrai // $v_2(n) = v_3(n)$
    \end{lstLNat}
    La complexité temporelle est en $\mc{O}(\log_6(n)) = \mc{O}(\log_2(n)) = \mc{O}(\abs{n})$. C'est une complexité linéaire en la taille de l'entrée~: $\abs{n} = \log_2(n)$.\\\\
    Moralité : toujours se ramener à une complexité en fonction de la taille de l'entrée.
\end{exemple}

\begin{remarque}{}{}
    La taille de l'entrée est à rapprocher de la taille du mot de $\{0;1\}$ que l'on écrit initialement sur une machine de Turing exécutant l'algorithme sur ce mot.
\end{remarque}

\subsection{Classe P}

\begin{definition}{}{classe P}
    On appelle \notion{classe P} (ou \notion{classe PTIME}) l'ensemble de \notion{problèmes de décision} que l'on peut résoudre à l'aide d'un algorithme de complexité polynomiale en la taille de l'entrée (pour un choix d'encodage).
\end{definition}

\begin{remarque}{}{}
    Généralement, on donne la complexité sous la forme $\mc{O}(\abs{e}^k)$ avec $k$ un entier (degré de l'expression polynomiale de la complexité) et $\abs{e}$ désignant la taille de l'entier.
\end{remarque}

\begin{remarque}{}{}
    Les problèmes de la classe P sont raisonnablement traitables. (Attention, on parle toujours uniquement de problème de décision).\\
    Pour considérer des problèmes d'optimisation, on se ramène à des problèmes de décision en introduisant un seuil à dépasser pour la fonction de coût.
\end{remarque}

\begin{remarque}{}{classe EXP}
    La \notion{classe EXP} (ou \notion{classe EXPTIME}) est la classe de problèmes de décision pour lesquels il existe un algorithme de résolution de complexité exponentielle~:
    $$\mc{O}(P(\abs{e})\exp(\abs{e}))$$
    où $P$ est un polynôme réel et $\abs{e}$ est la taille de l'entrée.
\end{remarque}

\begin{remarque}{}{comparaison entre EXP et P}
    On a P $\subset$ EXP car $e^n \gg P(n)$ pour $n \to +\infty$.
\end{remarque}

\begin{remarque}{}{}
    La complexité, soit le nombre d'opérations élémentaires, dépend du modèle de calcul choisi. Il en existe plusieurs.\\
    En MPI, on se place dans le cadre d'un modèle de calcul intuitif, qui correspond au fonctionnement d'un ordinateur exécutant un programmation en C ou en OCaml. Les opérations élémentaires sont alors les suivantes~:
    \begin{itemize}
        \item écriture
        \item lecture
        \item opération arithmétique
        \item etc (cf MP2I)
    \end{itemize}
    De plus on fait l'hypothèse que la machine dispose d'une \notion{mémoire infinie}~:
    \begin{itemize}
        \item la pile d'appels ne déborde jamais
        \item il n'y a pas de limite à la quantité de données allouable sur la pile, le tas ou bien le segment de données.
    \end{itemize}
    Un autre modèle de calcul classique est celui des machines de Turing~: on compte le nombre de transitions empruntées au cours d'un calcul.
\end{remarque}

\begin{exemple}{}{problème du dernier exemple}
    Le problème précédent (valuations) est de classe $P$ car linéaire et particulier polynomial.
\end{exemple}

\begin{exemple}{}{problème 2-SAT}
    \begin{itemize}
        \item \textbf{Instance}~: $\varphi$ une formule de la logique propositionnelle sous forme normale conjonctive dont les clauses sont de taille au plus 2.
        \item \textbf{Question}~: $\varphi$ est-elle satisfiable ?
    \end{itemize}
    On a 2-SAT $\in$ P. En effet, on peut construire le graphe d'implications puis lui appliquer l'algorithme de Kosaraju qui renvoie les composantes fortement connexes du graphe d'implications. On vérifie que pour $x \in \mc{V}_\varphi$, $x$ et $\lnot x$ ne sont pas dans la même composante fortement connexe. $\vaphi = C_1 \wedge \dots \wedge C_k$ de taille $\mc{O}(k) = \abs{\varphi}$.\\\\
    \notion{Construction du graphe}~:
    \begin{itemize}
        \item au plus $4k$ sommets (un par littéral)
        \item au plus $2k$ arêtes (deux par clause)
    \end{itemize}
    se fait en $\mc{O}(k)$\\
    Kosaraju  : $\mc{O(\abs{A} + \abs{S})}$ (deux parcours), se fait en 

    à finir
\end{exemple}

\subsection{Classe NP}

\begin{definition}{}{}
    Pour un problème de décision, on appelle \notion{certificat} une donnée que l'on peut ajouter à l'entrée permettant de vérifier que l'entrée est une instance positive.
\end{definition}

\begin{exemple}{}{}
    Pour le problème SAT, la donnée d'une valuation est un certificat. En effet, on vérifie que la valuation satisfait la formule pour vérifier qu'elle est satisfiable donc que c'est une instance positive.
    Pour toute formule $\varphi$, il existe une valuation $v$ telle que l'algorithme vérificateur confirme que $\varphi$ est satisfiable est satisfable.
\end{exemple}

\begin{exemple}{}{lié au problème K-COLOR}
    \begin{itemize}
        \item \textbf{Instance}~: $G=(S,A)$ un graphe, $k \in \N$.
        \item \textbf{Question}~: sur l'existence de $c:S\to \intint{1}{k}$ un coloriage des sommets à $k$ couleurs tel que~:
        $$\forall (u,v) \in A,\, c(u) \neq c(v)$$
    \end{itemize}
    On peut chosiir la donnée d'une fonction $c:S\to\intint{1}{k}$ comme certificat.
\end{exemple}

\begin{definition}{}{classe NP}
    La classe NP est l'ensemble des problèmes de décision pour lesquels il existe un \notion{algorithme vérificateur} permettant de \notion{vérifier} qu'une instance est positive à partir d'un couple (instance, certificat) en temps polynomial en la taille de l'instance, avec un certificat de taille polynomiale en fonction de cette taille.
\end{definition}

\begin{exemple}{}{problème SAT}
    Soit $\varphi$ une instance positive (une formule satisfiable) et $v$ un certificat associé à $\varphi$ (un modèle de $\varphi$)~:
    $$\abs{v} = \abs{\mc{V}_\varphi} = \abs{\varphi}$$
    L'algorithme vérificateur repose sur un parcours de l'arbre représentant $\varphi$ en $\mc{O}\Big(\abs{\varphi}\Big)$
\end{exemple}

\begin{remarque}{}{}
    L'algorithme vérificateur prend en entrée~:
    \begin{itemize}
        \item un encodage de l'instance
        \item un encodage du certificat
    \end{itemize}
    deux chaînes de caractères ! Si on choisit un certificat booléen, pour un instance $i^+$ positive, on note \code{verif} l'algorithme tel que~:
    \begin{itemize}
        \item \code{verif($i^+$,true)} renvoie \code{true}
        \item \code{verif($i^+$,false)} renvoie un booléen arbitraire
    \end{itemize}
    et pour $i^-$ une instance négative~:
    \begin{itemize}
        \item \code{verif($i^-$,true)} renvoie \code{false}
        \item \code{verif($i^-$,false)} renvoie \code{false}
    \end{itemize}
    Si on a un tel algorithme, alors on sait résoudre le problème avec cet algorithme et le certificat n'est pas nécessaire. Donc on ne pas prendre directement la solution comme un certificat ? 
    A montrer à ChatGPT, il saura m'expliquer.
\end{remarque}

\begin{definition}{}{formelle de classe NP}
    Soit $\mc{P}$ un problème de décision défini par sa fonction de prédicat $f: I \to \{Vrai, Faux\}$. $\mc{P}$ est de classe NP lorsqu'il existe~:
    \begin{enumeratebf}
        \item $\Sigma$ un alphabet permettant d'encoder un ensemble $C$ de certificats
        \item $\mc{P}'$ un problème de prédicat~:
        $$f': I\times \Sigma^* \to  S=\{Vrai, Faux\}$$
        \item $g$ une fonction polynomiale telle que pour tout $e\in I$, $f(e)$ est Vrai ssi~:
        $$\exists c \in C,\, \abs{c} \leq g(\code{e}) \quad \text{et} \quad f'(e,\abs{c}) = Vrai$$
        ($\abs{\cdot}$ désigne la taille de représentation)
        \item le problème $\mc{P}'$ est dans $\mc{P}$.
    \end{enumeratebf}
    L'algorithme en temps polynomial qui résout $\mc{P}'$ est appelé \notion{algorithme vérificateur}.
\end{definition}

\begin{remarque}{}{sur la définition}
    Dans la 3. : $\abs{c} \leq g(\abs{e})$ signifie que le certificat est de taille polynomiale en fonction de la taille de l'instance.
\end{remarque}

\begin{remarque}{}{}
    Pour montrer en pratique qu'un problème est dans NP~:
    \begin{itemize}
        \item on exhibe un certificat de taille polynomiale en fonction de l'instance
        \item on donne un algorithme vérificateur de complexité polynomiale en fonction de l'instance.
    \end{itemize}
\end{remarque}

\begin{exemple}{}{}
    On considère le problème CYCLE HAMILTONIEN~:
    \begin{itemize}
        \item \textbf{Instance}~: $G=(S,A)$ un graphe
        \item \textbf{Question}~: Existe-t-il un cycle passant exactement par tous les sommets de $S$ ?
        \item \textbf{Certificat}~: une permutation $\sigma$ de $S$.
    \end{itemize}
    \begin{lstLNat}
    VERIFICATEUR($G$,$\sigma$):
        n = $\abs{S}$
        vérifier que $\sigma$ est dans $\mc{S}_n$.
        pour i=1 jusqu'à n-1:
            Si $\Big(\sigma(i),\sigma(i+1)\Big) \notin A$:
                renvoyer false
        renvoyer ($\Big(\sigma(n),\sigma(1)\Big) \in A$)
    \end{lstLNat}
    Cet algorithme est de complexité en $\mc{O(\abs{S})}$ donc en temps polynomial en fonction de la taille de $G$ en mémoire : $\abs{S} + \abs{A}$ et $\abs{\sigma} = \abs{S}$ également polynomiale.
\end{exemple}

\begin{proposition}{}{classe P implique classe NP}
    P $\subset$ NP.
\end{proposition}

\begin{demonstration}
    On peut prendre n'importe quel certificat, on utilise l'algorithme résolvant $\pbm$ en temps polynomial comme algorithme vérificateur.
\end{demonstration}

\begin{remarque}{}{sens réciproque}
    Le sens réciproque est un problème ouvert. On ne connaît aucun exemple de problème de classe NP pour lequel on a une démonstration du fait qu'il n'est pas de classe P.
\end{remarque}

\subsection{Le problème d'optimisation}
Pour étudier la classe de complexité d'un problème d'opitimisation , one le transforme en problème de décision en ajoutant un \notion{seuil} à l'entrée. On répond alors à la question~:\\
"Existe-t-il une solution réalisable dont la valeur atteinte par la fonction de coût est supérieur (maximisation) ou inférieur (minimisation) à un seuil $s$ ?"\\\\

Le problème de décision associé est "moins compliqué". En particulier, si pour le problème de décision, on ne sait pas trouver d'algorithme en temps polynomial, on ne saura pas non plus pour le problème d'optimisation~: il est légitime de s'intéresse à des \notion{algorithmes d'approximation}.

\begin{remarque}{}{}
    Si le problème de décision est de classe P, on peut s'approcher le plus possible de la valeur optimale par dichotomie en utilisant plusieurs appels à l'algorithme de résolution en temps polynomial.
\end{remarque}
\\
On introduit la notation hors programme suivante.\\
La classe des problèmes d'optimisation dont le problème de décision associé est de classe P s'appelle la classe PO.
De même, pour la classe NP, la classe NPO.

\section{Réduction polynomiale}

\newcommand{\reductibleP}[]{\leq_m^\mr{P}}


\begin{definition}{}{réduction polynomiale}
    Soit deux problèmes de décision $\pbm_1$ et $\pbm_2$ définis par $f_1$ et $f_2$ leurs fonctions de prédicats associées définies sur un $I_1$ et $I_2$ respectivement. On dit que \notion{$\pbm_1$ se réduit à $\pbm_2$ de façon polynomiale} (noté $\pbm_1 \reductibleP \pbm_2$) lorsqu'il existe $g:I_1 \to I_2$ calculable avec un algorithme de complexité polynomiale telle que~:
    $$\forall e \in I_1,\, f_1(e) = f_2\Big(g(e)\Big)$$
\end{definition}

\begin{remarque}{}{}
    On a la même définition de réduction many-to-one que lorsqu'on discute de décidabilité, on uniquement l'hypothèse supplémentaire de l'existence d'un algorithme polynomial qui transforme les instances de $\pbm_1$ en des instances de $\pbm_2$.
\end{remarque}

\begin{proposition}{}{$\reductibleP$ est presque une relation d'ordre}
    La relation $\reductibleP$ est réflexive, transitive, mais non antisymétrique.
\end{proposition}
Voir démo 1

\begin{proposition}{}{}
    Soit $\pbm_1$ et $\pbm_2$ deux problèmes de décision. Si $\pbm_1 \reductibleP \pbm_2$ et $\pbm_2$ est de classe P, alors $\pbm_1$ est de classe P.
\end{proposition}

\begin{demonstration}
    Il suffit de combiner l'algorithme calculant $g$ et l'algorithme qui résout $\pbm_2$ en temps polynomial.
\end{demonstration}

Voir suite par Gwénolé.

\section{NP-completude, NP-difficile}

\subsection{Définitions et problème SAT}

\begin{definition}{}{}
    Un problème de décision est \notion{NP-difficile} ou \notion{NP-dur} lorsqu'il est possible de se ramener à tout problème de classe NP par une réduction polynomiale depuis ce problème.\\
    Moralement, il est plus difficile que tous les problèmes NP, mais on peut s'y ramener.
\end{definition}

\begin{definition}{}{}
    Soit $\pbm$ un problème de décision. $\mc{P}$ est NP-difficile si et seulement si~:
    $$\forall \mc{P}' \in \mr{NP},\, \mc{P}' \reductibleP \mc{P}$$
    Si de plus $\mc{P}$ est dans NP, alors $\mc{P}$ est \notion{NP-complet}.
\end{definition}

\begin{remarque}{}{}
    Pour montrer qu'un problème est NP-diffficile, on montre que SAT se réduit polynomialement à ce problème~: $\mr{SAT} \reductibleP \pbm$.
    On utilise donc la transitivité de $\reductibleP$.
\end{remarque}

\input{../../stock/pied.tex}