\input{../../stock/en-tete_v4.tex}
\begin{document}
\begin{adjustwidth}{-3cm}{-3cm}
\input{../../stock/commands.tex}
\newcounter{chapitre}
\setcounter{chapitre}{10}

\title{Chapitre 10 : Décidabilité}
\maketitle

Au programme : concepts à comprendre, démonstration à connaître !

\section{Problème de décision et décidabilité}

\begin{definition}{}{problème de décision}
    Un \notion{problème de décision} est un problème dont la réponse attendue est binaire : Vrai ou Faux. Plus précisément, un problème $\mc{P}$ est la donnée de~:
    \begin{itemize}
        \item $I$ un ensemble d'instances
        \item $S$ un ensemble de solutions : l'union des solutions pour chaque instance.
        \item $f : I \to S$ ou pour $i$ une instance, $f(i)$ est la réponse attendue pour l'instance $i$.
    \end{itemize}
    Pour un problème de décision, $S = \{\mr{Vrai}, \mr{Faux}\}$. On appelle la fonction $f$ \notion{fonction de prédicat} du problème $\mc{P}$ de décision.\\\\
    $\mc{P}$ peut aussi être défini à l'aide d'un sous-ensemble $P$ de $I \times S$ tel que ~:
    $$(i,s) \in P \Leftrightarrow s \text{ solution de $\mc{P}$ pour l'instance $i$}$$
\end{definition}



Pour $\mc{P}$ un problème de décision, défini par $f : I \to \{\mr{Vrai},\, \mr{Faux}\}$ sa fonction de prédicat, on définit~:
$$I_{\mc{P}}^+ = \{i \in I,\, f(i) = \mr{Vrai}\}$$
l'ensemble des \notion{instances passives} du problème $\mc{P}$ de décision.


\begin{definition}{}{décidabilité d'un problème de décision}
    Un problème de décision $\mc{P}$ est dit \notion{décidable} lorsqu'il existe $\mc{A}$ un algorithme qui pour toute instance du problème $\mc{P}$ renvoie la solution attendue.\\
    Autrement dit, pour $f : I \to S$ la fonction de prédicat de $\mc{P}$, il existe un algorithme $\mc{A}$ tel que~:
    $$\forall i \in I, f(i) = \mc{A}(i)$$
    $f(i)$ est ici la solution attendue tandis que $\mc{A}(i)$ est la solution attendue pour $i$.\\\\
    Le cas échéant, $\mc{A}$ termine pour toute instance.
    \notion{$\mc{A}$ résout $\mc{P}$} ou que \notion{$\mc{P}$ est décidé par $\mc{A}$}.
\end{definition}

\begin{definition}{}{indécidabilité d'un problème}
    Un problème de décision $\mc{P}$ est dit \notion{indécidable} lorsqu'il n'existe pas d'algorithme resolvant $\mc{P}$.
\end{definition}

\begin{remarque}{}{sur l'indécidabilité}
    Un problème indécidable est un problème intrinsèquement infaisable~: inutile d'essayer de le résoudre car c'est impossible.
\end{remarque}

\begin{exemple}{}{de problème décidable}
    $f : I \to S = \{\mr{Vrai},\, \mr{Faux}\}$\\
    $$f(\code{l}) = \mr{Vrai} \Leftrightarrow \text{\code{l} a exactement 5 éléments}$$
    $f$ est la fonction de prédicat d'un problème de décision~:
    \begin{itemize}
        \item \textbf{Instance}~: \code{l} une liste d'entiers
        \item \textbf{Question}~: Est-ce que \code{l} contient 5 éléments.
    \end{itemize}
    Ce problème est décidable car on peut écrire en OCaml~:
    \begin{lstOCaml}
    let longueur 5 l =
        match l with
        | e1::e2::e3::e4::e5::[] -> true
        | _ -> false
    \end{lstOCaml}
\end{exemple}

\subsection{semi-décidabilité (HP)}

\begin{definition}{}{semi-décidabilité d'un problème}
    Un problème de décision $\mc{P}$ défini par $f:I \to \{\mr{Vrai},\, \mr{Faux}\}$ est dit \notion{semi-décidable} lorsqu'il existe un algorithme $\mc{A}$ tel que pour $i \in I$~:
    \begin{itemize}
        \item si $f(i) = \mr{Vrai}$ alors $\mc{A}(i) = f(i)$ et $\mc{A}$ termine sur $i$.
        \item si $f(i) = \mr{Faux}$, alors $\mc{A}(i) = f(i)$ et $\mc{A}$ termine ou bien $\mc{A}$ ne termine pas sur $i$. Ecrire systeme.
    \end{itemize}
\end{definition}

\begin{exemple}{}{important}
    Il existe des problèmes non semi-décidables. On considère par exemple le suivant~:
    \begin{itemize}
        \item \textbf{Instance}~: une fonction \code{f : string -> bool} et \code{f} son code source.
        \item \textbf{Question}~: est ce que l'appel \code{f code\_f} ne renvoie pas true ? \ie est ce que l'appel renvoie false ou bien ne termine pas ? N'a-t-on que ces deux possibilités ?
    \end{itemize}
    Montrons que ce problème n'est pas semi-décidable.\\\\
    Supposons par l'absurde qu'il existe un algorithme $\mc{A}$ implémenté par une fonction \code{diag : string -> bool} qui semi-décide le problème. Par définition~:
    \begin{enumerate}
        \item \code{diag code\_f} renvoie \code{true} lorsque \code{f code\_f} ne renvoie pas \code{true}
        \item \code{diag code\_f} renvoie \code{false} ou ne termine pas lorsque \code{f code\_f} revoie true.
    \end{enumerate}
    On applique la fonction \code{diag} à son propre code, noté \code{code\_diag}.
    \begin{itemize}
        \item Si \code{diag code\_diag} renvoie \code{false}~: par définition de \code{diag} (2.), on a \code{diag code\_diag} renvoie \code{true}. Il y a alors contradiction.
        \item Si \code{diag code\_diag} renvoie \code{true}. Par définition de \code{diag} (1.), on a \code{diag code\_diag} ne renvoie pas \code{true}. C'est également absurde.
        \item Si \code{diag code\_diag} ne termine pas ou échoue, par définition de \code{diag} (2.), \code{diag code\_diag} renvoie \code{true}. On a une contradiction.
    \end{itemize}
    Aucune possibilité n'est viable. D'où l'absurdité de l'hypothèse.
\end{exemple}

\subsection{Problème de l'arrêt (au programme)}

\begin{definition}{}{problème de l'arrêt}
    Le \notion{problème de l'arrêt} est le problème qui consiste à décider si un programme ou un algorithme termine sur une entrée.
    \begin{itemize}
        \item \textbf{Instance}~: un programme \code{p} donné par son code \code{code\_p} et une entrée \code{x}
        \item \textbf{Question}~: est ce que l'appel \code{p x} termine ?
    \end{itemize}
\end{definition}

\begin{theoreme}{}{indécidabilité du problème de l'arrêt}
    Le problème de l'arrêt est indécidable.
\end{theoreme}
La démonstration est la suivante. Elle est à connaître impérativement.\\\\
\begin{demonstration}
    Supposons par l'absurde qu'il existe $\mc{A}$ un algorithme implément par une fonction \code{arret} qui résout le problème de l'arrêt. Par définition de décidabilité~:
    \begin{enumerate}
        \item \code{arret code\_p x} renvoie \code{true} lorsque \code{p x} termine.
        \item \code{arret code\_p code\_x} renvoie \code{false} lorsque \code{p x} ne termine pas.
    \end{enumerate}
    On écrit~:
    \begin{lstOCaml}
        let rec boucle (b:bool) :int =
            match b with
            | true -> boucle true
            | false -> 0
    
        let absurde code_p = boucle (arret code_p code_p)
    \end{lstOCaml}
    
    On s'intéresse à l'appel \code{arret code\_absurde code\_absurde}.
    \begin{itemize}
        \item Si \code{arret code\_absurde code\_absurde} renvoie \code{true}, par définition de \code{arret} (1.), \code{absurde code\_absurde} termine.
        Or cet appel \code{absurde code\_absurde} correspond à \code{boucle (arret code\_absurde code\_absurde)} qui ne termine pas par construction, alors que \code{arret code\_absurde code\_absurde} renvoie \code{true} : ceci constitue une contradiction.
        \item Si \code{arret code\_absurde code\_absurde} renvoie \code{false}. Par définition de \code{arret} (2.), \code{absurde code\_absurde} ne termine pas.
        Or \code{absurde code\_absurde} correspond à \code{boucle (arret code\_absurde code\_absurde)} qui termine par construction, alors que \notion{arret code\_absurde code\_absurde} renvoie \code{false}. Contradiction.
    \end{itemize}
\end{demonstration}



\begin{remarque}{}{usage de chaînes de caractères}
    Dans les démonstrations, on préfèrera la manipulation de chaînes de caractères associées à ce qui n'en est pas. En effet, en machine, tout est représenté par des chaînes et en particulier les machines de Turing ne manipulent que ça. C'est plus formel.
\end{remarque}

Fin cours 12/02/2025

\section{Réduction (entre problèmes de décision)}

\newcommand{\algo}[]{\mc{A}}


\begin{definition}{}{fonction calculable}
    Une fonction $f : E \to F$ est dite \notion{calculable} lorsqu'il existe un algorithme $\algo$ tel que pour toute entrée $e \in E$, $\algo$ appliqué à $e$ termine et renvoie $f(e)$ en un temps fini.
\end{definition}

\begin{remarque}{}{importante sur les fonctions calculables}
    Il existe des fonctions qui ne sont pas calculables~:
    \begin{itemize}
        \item $\{0;1\}^\N$ est indénombrable
        \item l'ensemble des algorithmes est dénombrable, car on peut numéroter chaque possibilité du $i$-ème caractère, puis le produit cartésien d'ensembles dénombrables est dénombrables~:
        $$\abs{\algo} \leq \abs{\Sigma^*} = \abs{\bigcup_{n \in \N}\Sigma^n}$$
        On peut les énumérer par taille.
    \end{itemize}
\end{remarque}

\begin{remarque}{}{}
    Il existe moins d'algorithmes que de fonctions.
\end{remarque}
\newcommand{\pbm}[]{\mc{P}}


\begin{definition}{}{réduction calculatoire}
    Soit $\pbm_1$ et $\pbm_2$ deux problèmes de décision définis par leurs fonction de prédicat $f_1 : I_1 \to \{\mr{Vrai},\, \mr{Faux}\}$ et $f_2 : I_2 \to \{\mr{Vrai},\, \mr{Faux}\}$. On dit que \notion{$\pbm_1$ se réduit calculatoirement à $\pbm_2$} ($\pbm_1 \leq_m \pbm_2$), lorsqu'il existe $g : I_1 \to I_2$ une fonction calculable telle que~:
    $$\forall e \in I_1,\, f_1(e) = f_2\Big(g(e)\Big)$$
\end{definition}

\begin{remarque}{}{réduction calculatoire}
    $\pbm_1 \leq_m \pbm_2$ revient à dire que "$\pbm_1$ est plus facile que $\pbm_2$".\\
    On note $\algo_2$ un algorithme qui résout $\mc{P}_2$ et $\mc{A}_g$ un algorithme qui calcule la fonction $g$. On pose alors $\mc{A}_1$ l'algorithme~:
    \begin{lstLNat}
    $\algo_1$(e):
        e' = $\algo_g$(e)
        renvoyer $\algo_2$(e')
    \end{lstLNat}
    $\algo_1$ résout alors $\pbm_1$.
\end{remarque}

\begin{proposition}{}{}
    Soit $\pbm_1$ et $\pbm_2$ deux problèmes de décision définis par leurs fonction de prédicat $f_1 : I_1 \to \{\mr{Vrai},\, \mr{Faux}\}$ et $f_2 : I_2 \to \{\mr{Vrai},\, \mr{Faux}\}$. Si $\pbm_1 \leq_m \pbm_2$ et $\mc{P}_1$ est indécidable, alors $\pbm_2$ est indécidable.
\end{proposition}

\begin{demonstration}
    Supposons par l'absurde $\pbm_2$ décidable, alors il existe $\algo_2$ un algorithme qui résout $\pbm_2$. $\pbm_1 \leq_m \pbm_2$ donne l'existence de $g : I_1 \to I_2$ calculable telle que~:
    $$\forall e \in I_1,\, f_1(e) = f_2\Big(g(e)\Big)$$
    On construit $\mc{A_1}$ comme dans la remarque précédente, il résout $\mc{P_1}$. D'où la contradiction.
\end{demonstration}

\begin{exemple}{}{problème ZERO (V1)}
    Le problème ZERO est le suivant~:
    \begin{itemize}
        \item \textbf{Instance} : Une fonction (en programmation) \code{f} de code \code{code_f} et une entrée \code{x}.
        \item \textbf{Question} : Est-ce que \code{f} appliquée à \code{x} renvoie \code{0} ?
    \end{itemize}
    On cherche à montrer que ZERO est indécidable. Pour cela on peut montrer~:
    $$\mr{ARRET} \leq_m \mr{ZERO}$$
    On pose~:
    $$g : (\code{f},\, \code{x}) \mapsto (\code{f'},\, \code{x})$$
    où \code{f'} est définie par~:
    \begin{lstLNat}
    let f' x = let _ = f x in 0
    \end{lstLNat}
    qui calcule \code{f x}, et renvoie \code{0}.\\\\

    $g$ est calculable, car un algorithme transformant $(\code{f},\, \code{x})$ en $(\code{f'},\, \code{x})$ est le suivant~:
    \begin{lstLNat}
    let g f =
        let f' x = let _ 0 = f x in 0
        in f'
    \end{lstLNat}
    \begin{itemize}
        \item Si $(\code{f},\, \code{x}) \in \mr{ARRET}^+$ (instance positive de ARRET), alors \code{f x} termine, puis \code{f' x} termine et renvoie \code{0}. On a bien $(\code{f'},\, \code{x}) \in \mr{ZERO}^+$
        \item Si $(\code{f},\, \code{x}) \notin \mr{ARRET}^+$, alors $\code{f x}$ ne termine pas, donc $\code{f' x}$ ne termine pas et ne renvoie pas \code{0}, donc $(\code{f'},\, \code{x}) \notin \mr{ZERO}^+$
    \end{itemize}
    On a $(\code{f},\, \code{x}) \in \mr{ARRET}^+ \Leftrightarrow (\code{f'},\, \code{x}) \in \mr{ZERO}^+$
\end{exemple}

\begin{exemple}{numero}{problème ZERO (V2)}
    à recopier
\end{exemple}

\begin{remarque}{}{many to one}
    Cette façon de faire des réductions entre problèmes s'appelle réduction "\notion{many to one}" car la fonction $g$ n'est pas toujours injective : on peut avoir plusieurs instances pour une seule et même sortie (en parlant de $g$).
\end{remarque}

\section{Complément HP : coproblème}

\newcommand{\copbm}[]{\mr{co}\mc{P}}


\begin{definition}{}{coproblème}
    Soit $\pbm$ un problème de décision défini par $f:I \to \{\mr{Vrai},\mr{Faux}\}$. On définit le \notion{coproblème} de $\pbm$, noté $\copbm$ par la fonction de prédicat~:
    \fonction{\mr{co}f}{I}{\{\mr{Vrai},\, \mr{Faux}\}}{e}{\begin{cases*}
    \mr{Vrai} &si $f(e) = \mr{Faux}$ \\
    \mr{Faux} &si $f(e) = \mr{Vrai}$
    \end{cases*}}
    Autrement dit, on fait la négation de la question correspondante.
\end{definition}

\begin{exemple}{}{coARRET}
    \begin{itemize}
        \item \textbf{Instance}~: un programme \code{p} donné par son code \code{code\_p} et une entrée \code{x}
        \item \textbf{Question}~: est ce que l'appel \code{p x} ne termine pas ?
    \end{itemize}
\end{exemple}

\begin{proposition}{}{}
    Soit $\pbm$ un problème de décision. Si $\pbm$ et $\copbm$ sont semi-décidable, alors ils sont décidables.
\end{proposition}

\begin{demonstration}
    On a $\algo$ et $co\algo$ deux algorithmes qui semi-décident $\mc{P}$ et $\copbm$.\\
    Pour une instance positive de $\pbm$, $\algo$ termine et pour une instance négative, c'est $co\algo$ termine. On les lance en parallèle~:
    \begin{lstLNat}
    semaphore s initialise à 0
    r variable globale
    RESOUT(e):
        r = $\mr{A}$(e)
        s.post()
    
    CORESOUT(e):
        r = NOT(co$\mc{A}$(e))
        s.post()

    ALGORITHME(e):
        T1 = fil réalisant RESOUT(e)
        T2 = fil réalisant CORESOUT(e)
        s.wait()
        renvoyer r
    \end{lstLNat}
\end{demonstration}

\begin{definition}{}{co-semi-décidabilité}
    Pour $\pbm$ un problème de décision, lorsque $\copbm$ est semi-décidable, on dit que \notion{$\mc{P}$ est co-semi-décidable}.
\end{definition}

\input{../../stock/pied.tex}