\input{../stock/en-tete.tex}

\begin{question}{I.1) }{Définition inductive de la concaténation en Ocaml}
    Pour toutes listes \code{l} et \code{q}, et tout élément \code{e} :
    $\begin{cases}
        \code{[]@l = l} \\
        \code{(e::q@l = e::(q@l))}
    \end{cases}$

\end{question}

\begin{question}{I.2) }{Rédaction de démonstration par induction structurelle}
    Soit \code{l2} une liste.
    Montrons par récurrence structurelle sur \code{l1} que $|\code{l1 @ l2}| = |\code{l1} + \code{l2}|$ pour toutes listes \code{l1} et \code{l2}.
   \begin{itemize}
       \item Si \code{l1 = []}, $|\code{l1 @ l2}| = |\code{l2}| = |\code{l1}| + |\code{l2}|$
       \item Si \code{l1 = e::q}, \hbox{supposons que} $|\code{q @ l2}| = |\code{q}| + |\code{l2}|$, pour toute suite l2 (\notion{hypothèse d'induction}) 
    \end{itemize}
    \begin{align*}
        |\code{l1 @ l2}| & = |\code{(e::q) @ l2}| && \\
        & = |\code{e::(q @ l2)}| \quad &&\text{par définition de \code{@}} \\
        & = 1 + |\code{q @ l2}| &&\text{par définition de $\code{l} \mapsto \code{l}$} \\
        & = 1 + |\code{q}| + |\code{l2}|  &&\text{par hypothèse d'induction} \\
        & = |\code{e::q}| + |\code{l2}| && \\
        |\code{l1 @ l2}| & = |\code{l1}| + |\code{l2}| &&
    \end{align*}
    % Ainsi, par induction structurelle, $|\code{l1 @ l2}| = |\code{l1}| + |\code{l2}|$, pour toutes listes \code{l1} et \code{l2}, et ce, indépendamment du choix de |\code{l2}|
\end{question}

\input{../stock/pied.tex}