\input{../stock/commands.tex}
\input{../stock/en-tete_v2.tex}

\begin{question}{I.1) }{Définition inductive de la concaténation en Ocaml}
    Pour toutes listes \code{l} et \code{q}, et tout élément \code{e} :
    $\begin{cases}
        \code{[] @ l = l} \\
        \code{(e::q @ l = e::(q @ l))}
    \end{cases}$

\end{question}

\begin{question}{I.2) }{Rédaction de démonstration par induction structurelle}
    Soit \code{l2} une liste.
    Montrons par récurrence structurelle sur \code{l1} que $\ccode{l1 @ l2} = \ccode{l1 + l2}$ pour toutes listes \code{l1} et \code{l2}.
   \begin{itemize}
       \item Si \code{l1 = []}, $\ccode{l1 @ l2} = \ccode{l2} = \ccode{l1 + l2}$
       \item Si $\code{l1} = \code{e::q}$, \hbox{supposons que} $\ccode{q @ l2} = \ccode{q} + \ccode{l2}$, pour toute suite l2 (\notion{hypothèse d'induction}) ()
    \end{itemize}
    \begin{align*}
        \ccode{l1 @ l2} & = \ccode{(e::q) @ l2} && \\
        & = \ccode{e::(q @ l2)} \quad &&\text{par définition de \code{@}} \\
        & = 1 + \ccode{q @ l2} &&\text{par définition de $\code{l} \mapsto \code{l}$} \\
        & = 1 + \ccode{q} + \ccode{l2}  &&\text{par hypothèse d'induction} \\
        & = \ccode{e::q} + \ccode{l2} && \\
        \ccode{l1 @ l2} & = \ccode{l1} + \ccode{l2} &&
    \end{align*}
    Ainsi, par induction structurelle, $\ccode{l1 @ l2} = \ccode{l1} + \ccode{l2}$, pour toutes listes \code{l1} et \code{l2}, et ce, indépendamment du choix de \code{l2}
\end{question}


\begin{question}{II.1) }{$\crev{l1} = \ccode{l1}$}
    Montrons par induction structurelle sur \code{l1} que pour toute liste \code{l1}, $\crev{l1} = \ccode{l1}$. \begin{itemize}
        \item Si $\code{l1} = []$, $\rev{l1} = \rev{[]} = \code{[]}  = \code{l1}$
        \item Si $\code{l1} = \code{e::q}$, on suppose que $\crev{q} = \ccode{q}$ \begin{align*}
            \crev{l1} &= \crev{e::q} &&\\
            &= \code{|reverse(q) @ [e]|} && \text{définition de \code{reverse}}\\
            &= \crev{q} + \ccode{[e]} && \\
            &= \ccode{q} + \ccode{[e]} && \text{hypothèse d'induction}\\
            &= \ccode{e::q} && \\
            \crev{l1} &= \ccode{l1} &&
        \end{align*}
    \end{itemize}
    Ainsi, par induction structurelle, pour toute liste \code{l1}, $\crev{l1} = \ccode{l1}$.
\end{question}

\begin{question}{II.1) }{$\rev{l1 @ l2} = \code{\rev{l2} @ \rev{l1}}$}
    Montrons, par induction structurelle sur \code{l1}, que pour toute liste \code{l1}, $$\rev{l1 @ l2} = \code{\rev{l2} @ \rev{l1}}$$. \begin{itemize}
        \item Si $\code{l1} = \code{[]}$, alors $\rev{[] @ l2} = \rev{l2} = \code{\rev{l2} @ \rev{[]}}$        
        \item Si $\code{l1} = \code{e::q}$, supposons que $\rev{q @ l2} = \code{\rev{l2} @ \rev{q}}$. \begin{align*}
            \text{Alors, } \rev{l1 @ l2} &= \rev{e::q @ l2} && \\
            &= \code{\rev{q @ l2} @ [e]} && \text{par définition} \\
            &= \code{\rev{l2} @ \rev{q} @ [e]} && \text{hypothèse d'induction} \\
            &= \code{\rev{l2} @ \rev{e::q}} && \text{par définition} \\
            &= \code{\rev{l2} @ \rev{l1}}
        \end{align*}
    \end{itemize}
    Donc, par induction structurelle sur \code{l1}, $\forall \code{l1}, \rev{l1 @ l2} = \code{\rev{l2} @ \rev{l1}}$
\end{question}

\begin{question}{II.2) }{}
    Pour tout $n \in \mb{N}$ on pose $C_n$ la complexité en pire cas d'un appel \code{reverse liste}, où $\ccode{liste} = n$. \\
    Un appel sur une liste non vide $\code{liste} = \code{e::q}$ engendre un appel récursif sur la liste \code{q}. De plus, l'opérateur \code{@} a une complexité linéaire par rapport à la taille de la première liste. \\ \\ Évaluation de la complexité :\begin{itemize}
        \item \underline{Version courte} \\ Donc $C_n = \mc{O}(n^2)$
        \item \underline{Version longue} \\ Soit $A > 0$ (\notion{$A$ est la grandeur qui prend en facteur l'argument du $\mc{O}$}) tel que : $\begin{cases}
            \forall n \in \mb{N}, C_{n+1} \leq C_n + An \\
            C_0 \leq A
        \end{cases}$
        \begin{align*}
            \text{Donc} \quad \forall n \in \mb{N}, C_n &= [\sum_{k=0}^{n-1}(C_{k+1}-C_k)] + C_0 \\
            &\leq [\sum_{k=0}^{n-1}An] + A \\
            &= A \frac{n(n-1)}{2} + A \\
            &= A(\frac{n(n-1)}{2} + 1) 
        \end{align*}
    \end{itemize}
\end{question}

\begin{question}{II.3) }{}
    \begin{verbatim}
        let renv liste = 
            let rec transfert l q = match l with 
            (* renvoie reverse(l) @ q *)
                | [] -> q
                | e::t -> transfert t (e::q)
            in transfert liste []
    \end{verbatim}
    \begin{itemize}
        \item \underline{Correction de la fonction \code{transfert}} \\ On prouve par induction structurelle sur \code{l} que \code{transfert l q} termine et renvoie \code{\rev{l} @ q}, pour toutes listes \code{l} et \code{q}. \begin{itemize}
            \item Si $\code{l} = \code{[]}$, \code{transfert l q} termine et renvoie \code{q = \rev{[]} @ q}, pour toute liste \code{q}
            \item Sinon, $\code{l} = \code{e::t}$ : on suppose que pour toute liste \code{q}, \\ \code{transfert t q} termine et renvoie \code{\rev{t} @ q} \\ Pour toute liste \code{q}, l'appel \code{transfert l q} effectue un appel récursif \code{transfert t (e::q)} qui termine et renvoie \code{\rev{t} @ (e::q)} par hypothèse d'induction.\\
            Or $\ccode{l} = \ccode{e::t} = \code{\rev{t} @ [e]}$ \\
            Donc \begin{align*}
                \code{\rev{l} @ q} &= \code{\rev{t} @ [e] @ q} \\
                &= \code{\rev{t} @ (e::q)}
            \end{align*}
            Donc \code{transfert l q} termine et renvoie [...] \\
            D'où, par induction structurelle sur \code{l}, pour toutes listes \code{l} et \code{q}, \code{transfert l q} termine et renvoie [...]
            D'où la correction de \code{transfert}. On termine par la correction de \code{renv}.
        \end{itemize}
    \end{itemize}
\end{question}

\begin{question}{II.5 )}{Complexité de \code{transfert}}
    Un appel \code{transfert (e::t) q} évalue \code{e::q} en temps constant pour effectuer un appel récursif \code{transfert t (e::q)}. \\
    En notant $C_n$ la complexité d'un appel \code{transfert l q} où \code{l} est une liste de taille $n$ : $$C_{n+1} = C_n + \Theta(1)$$
    Donc $C_n = \Theta(n)$. Un appel \code{renv l} a donc une complexité $\Theta(\ccode{l})$
\end{question}

\begin{question}{III.1) }{}
    \begin{verbatim}
        let rec separe l l1 l2 = match l with
            |[] -> (l1,l2)
            | e::q -> separe q (e::l2) l1
    \end{verbatim}
\end{question}

\begin{question}{III.2) }{}
    À chaque appel récursif, la taille ($\in \mb{N}$) de la première liste passée en argument diminue de $1$, celle-ci constitue donc un variant aux appels issus de l'appel initial \code{separe l l1 l2}, ce qui prouve la terminaison de cet appel. \\ \\
    On montre par induction structurelle sur \code{l} que pour toutes listes \code{l1} et \code{l2} telles que $\ccode{l1} = \ccode{l2}$ ou $\ccode{l1} = \ccode{l2} + 1$, le couple \code{(L1, L2)} renvoyé par l'appel \code{separe l l1 l2} est tel que \code{L1 @ L2} soit une permutation de \code{l @ l1 @ l2} et ($\ccode{L1} = \ccode{L2}$ ou $\ccode{L1} = \ccode{l2}+1$). \begin{itemize}
        \item Si $\code{l} = \code{[]}$ : Pour toutes listes \code{l1}, \code{l2}, tq 
    \end{itemize}


    \underline{Correction de la fonction \code{separe}}
    Montrons par induction structurelle la propriété : $$P(\code{l}) : ""$$
    - Si $l = []$, pour toutes listes $l1,l2$ tq $\ccode{l1} = \ccode{l2}$ ou $\ccode{l1} = \ccode{l2} + 1$. L'appel \code{separe l l1 l2} renvoie le couple \code{(l1, l2)} avec $\code{l @ l1 @ l2} = \code{l1 @ l2}$. $P(\code{l})$ est donc vérifiée.
    - Si \code{l = e::q}, on suppose que $P(\code{q})$ est vraie.
    Soit \code{l1} et \code{l2} tq $\ccode{l1} = \ccode{l2}$ ou $\ccode{l1} = \ccode{l2} + 1$, l'appel \code{separe l l1 l2} évalue l'appel \code{separe q (e::l2) l1}. Or $\ccode{e::l2} = 1 + \ccode{l2} = 1 + \ccode{l1}$
    Par hypothèse d'induction structurelle, l'appel \code{separe q (e::l2) l1} renvoie (l1,l2) tel que \code{l1 @ l2} est une permutation de \code{q @ (e::l2) @ l1} et ($\ccode{l1} = \ccode{l2}$ ou $\ccode{l1} = \ccode{l2} + 1$). \\ Donc $P(\code{l})$ est vérifiée. \\ \\
    Par ibduction structurelle sur \code{l}, pour toutes listes \code{l}, \code{l1}, \code{l2} tq \dots, l'appel \code{separe l l1 l2} \dots
\end{question}

\begin{question}{III.3) }
    En notant $C(n)$ la compexité d'un appel \code{separe l l1 l2} où \code{l} est de taille $n$, on a $C(n+1) = C(n) + \mc{O}(1)$. Alors $C(n) = \mc{O}(n)$. \\
    De plus, \code{separe} étant récursive terminale, elle a une complexité constante sur la pile d'appel. sur le tas en revanche, on construit les deux listes \code{l1} et \code{l2} par ajouts successifs d'un élément en tête, avec une complexité linéaire. Finalement, la complexité spatiale est linéaire en la somme des tailles des listes. \\ \textit{Voir Figure 1 au dos du sujet}
\end{question}

\begin{question}{III.4) }
    \begin{verbatim}
let rec fusionne liste l1 l2 match l1, l2 with
    | [], l | l, [] -> (rev liste) @ l
    | e1::q1, e2::q2 -> 
        if e1 < e2 then fusionne (e1 :: liste) q1 l2
        else fusionne (e2::liste) l1 q2
    \end{verbatim}
\end{question}

\begin{question}{III.5) }
    Montrons par récurrence sur $n$ $$P(n) : "\text{pour tout $k \in \N, \code{l1}, \code{l2} $ telles que n = $\ccode{l1} + \ccode{l2} = n$, avec \code{l1} et \code{l2} triées dans l'ordre croissant, et \code{l} une liste triée dans l'ordre décroissant dont tous les éléments sont inférieurs à ceux de \code{l1} et \code{l2}, l'appel \code{fusionne l l1 l2} termine et renvoie une permutation triée dans l'ordre croissant de \code{l@l1@ l2}}"$$est vraie pour tout $n \in \N$. \\
    Initialisation : 
        Si $\code{l1} + \code{l2} = 0$ et $\code{l1} = \code{[]}$ et $\code{l2} = \code{[]}$ alors l'appel \code{fusionne l l1 l2} termine et renvoie \code{(renv l) qui est bien une permutation triée dans l'ordre croissant de \code{l@[]@[]}. $P(0)$ est vraie. \\
        Hérédité : On fixe $n \in \N$, on suppose que $P(n)$ est vraie. Montrons que $P(n+1)$ l'est aussi. Soit \code{l1 l2} triées tq $\ccode{l1} + \ccode{l2} = n+1$ pour toute liste \code{l} détriée, dont les éléments\dots \begin{itemize}
        \item Si $\code{l1} = \code{[]}$ ou $\code{l2} = \code{[]}$, l'appel \code{fusionne l l1 l2} termine et renvoie une permutation triée dans l'ordre croissant de \code{l @ l1 @ l2} car les éléments de \code{l} sont \dots.
        \item sinon, $\code{l1} = \code{e1::q1}$ et $\code{l2} = \code{e2:q2}$ \begin{itemize}
            \item si $\code{e1} < \code{e2}$, alors lors de l'appel \codee{fusionne l l1 l2}, on évalue l'appel \code{fusionne (e2::liste) q1 l2} et comme $\ccode{q1} + \ccode{q2} = n$ et les éléments de \code{e1::l} sont inférieurs ou égaux à ceux de \code{q1} et de \code{l2}, car $\code{e1}<\code{e2}$ et \code{e1::l} est triée dans l'ordre croissant car les éléments de \code{l} sont \dots, d'après l'hypothèse de récurrence, cet appel termine et renvoie une permutation triée de \code{e1::l @ q1 @ l2}, i.e. de \code{l @ l1 @ l2}.
            \item Sinon, on montre de même que l'appel termine et renvoie une permutation triée de \code{l @ l1 @ l2}. Donc $P(n+1)$ est vraie 
        \end{itemize}
        \end{itemize}
        Par récurence, pour tout $n \in \N$, $P(n)$, d'où la correction totale de \code{fusionne}
\end{question}

\begin{question}{III.6) }
    Lors d'un appel \code{fusionne liste l1 l2}, les différents appels récursifs se font sur la queue de la deuxième liste, la troisième liste étant identique, ou l'inverse, il y a donc au maximum $\ccode{l1} + \ccode{l2}$ appels récursifs, les autres opérations se font en temps constant sauf lors du dernier appel récursif, de la forme \code{fusionne l' [] l} ou \code{fusionne l' l []} avec $\ccode{l'} \leq \ccode{liste} + \ccode{l1} + \ccode{l2}$.\\Or lors de ce dernier appel on évalue d'abord \code{(renv l ')} en $\mc{O}(\ccode{l'})$ puis on renvoie \code{(renv l') @ l} à nouveau en $\mc{O}(\ccode{l'})$. \\ La complexité d'un appel \code{fusionne liste l1 l2} est donc en $\mc{O}(\ccode{liste} + \ccode{l1} + \ccode{l2})$
\end{question}

\begin{question}{III.7) }
    \begin{verbatim}
        let rec tri_fusion l = match l with
        | [] | [_] -> l
        | _ -> let l1, l2 = separe l [] [] in
            fusionne [] (tri_fusion l1) (tri_fusion l2)
    \end{verbatim}
\end{question}

\begin{question}{III.8) }
    Pour une liste \code{l} de taille $n \geq 2$, l'appel \code{tri_fusion l} effecue : \begin{itemize}
        \item un appel à la fonction separe en $\mc{O}(n)$
        \item deux appels récursifs sur des listes de tailles $\lfloor \frac{n}{2} \rfloor $ et $\lceil  \frac{n}{2} \rceil $
        \item un appel à \code{fusionne} en $\mc{O}(n)$.
    \end{itemize}
    En notant, pour tout $n \in \N$, $C(n)$ la complexité dans le pire cas d'un appel \code{tri_fusion l} où $\ccode{l} = n$, $$C(n) = C(\lfloor \frac{n}{2}\rfloor) + C(\lceil \frac{n}{2}) \rceil + \mc{O}(n)$$
    Pour tout $p \in \N$ on a donc \begin{align*}
        &C(2^{p+1}) = 2C(2^p) + \mc{O}(2^{p+1}) \\
        \text{donc}\quad \frac{C(2^{k+1})}{2^{p+1}} &= \frac{C(2^p)}{2^p} + \mc{O}(1) \\
        \text{d'où}\quad \frac{C(2^p)}{2^p} &= \mc{O}(p) \\
        \text{puis}\quad C(2^p) = \mc{O}(p2^p) \\
        \text{De plus, si $n = 2^p$}, p &= \log_2{n}
    \end{align*}
    En supposant de plus que la complexité est croissante, on a pour $n$ quelconque $$C(n) = \mc{O}(n \log(n))$$.
\end{question}
\input{../stock/pied.tex}